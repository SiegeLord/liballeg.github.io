<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"
><head
  ><title
    >Audio addon</title
    ><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"
     /><meta name="generator" content="pandoc"
     /><script type="text/javascript" src="autosuggest.js"></script>
<script type="text/javascript" src="search_index.js"></script>
<link rel="stylesheet" href="pandoc.css" type="text/css" media="all" />
</head
  ><body
  ><table class="white">
<tr>
<td valign="top" class="sidebar">

<div class="sidebar">
<ul
><li
  ><a href="index.html"
    >Front</a
    ></li
  ><li
  ><a href="config.html"
    >Configuration files</a
    ></li
  ><li
  ><a href="display.html"
    >Display</a
    ></li
  ><li
  ><a href="events.html"
    >Events</a
    ></li
  ><li
  ><a href="file.html"
    >File I/O</a
    ></li
  ><li
  ><a href="fshook.html"
    >Filesystem hooks</a
    ></li
  ><li
  ><a href="graphics.html"
    >Graphics</a
    ></li
  ><li
  ><a href="joystick.html"
    >Joystick</a
    ></li
  ><li
  ><a href="keyboard.html"
    >Keyboard</a
    ></li
  ><li
  ><a href="memory.html"
    >Memory</a
    ></li
  ><li
  ><a href="misc.html"
    >Miscellaneous</a
    ></li
  ><li
  ><a href="mouse.html"
    >Mouse</a
    ></li
  ><li
  ><a href="opengl.html"
    >OpenGL</a
    ></li
  ><li
  ><a href="path.html"
    >Path</a
    ></li
  ><li
  ><a href="state.html"
    >State</a
    ></li
  ><li
  ><a href="system.html"
    >System</a
    ></li
  ><li
  ><a href="threads.html"
    >Threads</a
    ></li
  ><li
  ><a href="time.html"
    >Time</a
    ></li
  ><li
  ><a href="timer.html"
    >Timer</a
    ></li
  ><li
  ><a href="utf8.html"
    >UTF-8</a
    ></li
  ><li
  ><a href="kcm_audio.html"
    >Audio addon</a
    ></li
  ><li
  ><a href="acodec.html"
    >Audio codecs</a
    ></li
  ><li
  ><a href="color.html"
    >Color addon</a
    ></li
  ><li
  ><a href="font.html"
    >Font addons</a
    ></li
  ><li
  ><a href="iio.html"
    >Image I/O addon</a
    ></li
  ><li
  ><a href="native_dialog.html"
    >Native dialogs addon</a
    ></li
  ><li
  ><a href="physfs.html"
    >PhysicsFS addon</a
    ></li
  ><li
  ><a href="primitives.html"
    >Primitives addon</a
    ></li
  ></ul
><!-- keep blank line for correct HTML -->
</div>

<div class="searchbox">
<script type="text/javascript">
function onSubmit(form) {
    for (i = 0; i < search_index.length; i++) {
        if (search_index[i] == form.q.value) {
            form.action = search_urls[i];
            form.method = "POST";
            return true;
        }
    }
    // Search-term is not in the index.
    // We could add an URL here which does a fulltext search - for
    // now we simply do nothing by return false to the form.
    return false;
}
</script>
<form id="search" action="search.py" onSubmit="return onSubmit(this);"><input type="text" name="q" id="q" autocomplete="off" /><br /> <input type="submit" value="Search" /><script>actb = new actb("q", search_index);</script>
</form>
</div>


</td>
<td class="content">


<h1 class="title"
    >Audio addon</h1
    ><div id="toc"
    ><ul
      ><li
	><a href="#audio-types" id="TOC-audio-types"
	  >Audio types</a
	  ><ul
	  ><li
	    ><a href="#allegro_audio_depth" id="TOC-allegro_audio_depth"
	      >ALLEGRO_AUDIO_DEPTH</a
	      ></li
	    ><li
	    ><a href="#allegro_audio_driver_enum" id="TOC-allegro_audio_driver_enum"
	      >ALLEGRO_AUDIO_DRIVER_ENUM</a
	      ></li
	    ><li
	    ><a href="#allegro_audio_pan_none" id="TOC-allegro_audio_pan_none"
	      >ALLEGRO_AUDIO_PAN_NONE</a
	      ></li
	    ><li
	    ><a href="#allegro_channel_conf" id="TOC-allegro_channel_conf"
	      >ALLEGRO_CHANNEL_CONF</a
	      ></li
	    ><li
	    ><a href="#allegro_mixer" id="TOC-allegro_mixer"
	      >ALLEGRO_MIXER</a
	      ></li
	    ><li
	    ><a href="#allegro_mixer_quality" id="TOC-allegro_mixer_quality"
	      >ALLEGRO_MIXER_QUALITY</a
	      ></li
	    ><li
	    ><a href="#allegro_playmode" id="TOC-allegro_playmode"
	      >ALLEGRO_PLAYMODE</a
	      ></li
	    ><li
	    ><a href="#allegro_sample_id" id="TOC-allegro_sample_id"
	      >ALLEGRO_SAMPLE_ID</a
	      ></li
	    ><li
	    ><a href="#allegro_sample" id="TOC-allegro_sample"
	      >ALLEGRO_SAMPLE</a
	      ></li
	    ><li
	    ><a href="#allegro_sample_instance" id="TOC-allegro_sample_instance"
	      >ALLEGRO_SAMPLE_INSTANCE</a
	      ></li
	    ><li
	    ><a href="#allegro_stream" id="TOC-allegro_stream"
	      >ALLEGRO_STREAM</a
	      ></li
	    ><li
	    ><a href="#allegro_voice" id="TOC-allegro_voice"
	      >ALLEGRO_VOICE</a
	      ></li
	    ></ul
	  ></li
	><li
	><a href="#setting-up" id="TOC-setting-up"
	  >Setting up</a
	  ><ul
	  ><li
	    ><a href="#al_install_audio" id="TOC-al_install_audio"
	      >al_install_audio</a
	      ></li
	    ><li
	    ><a href="#al_uninstall_audio" id="TOC-al_uninstall_audio"
	      >al_uninstall_audio</a
	      ></li
	    ><li
	    ><a href="#al_reserve_samples" id="TOC-al_reserve_samples"
	      >al_reserve_samples</a
	      ></li
	    ></ul
	  ></li
	><li
	><a href="#voice-functions" id="TOC-voice-functions"
	  >Voice functions</a
	  ><ul
	  ><li
	    ><a href="#al_create_voice" id="TOC-al_create_voice"
	      >al_create_voice</a
	      ></li
	    ><li
	    ><a href="#al_destroy_voice" id="TOC-al_destroy_voice"
	      >al_destroy_voice</a
	      ></li
	    ><li
	    ><a href="#al_detach_voice" id="TOC-al_detach_voice"
	      >al_detach_voice</a
	      ></li
	    ><li
	    ><a href="#al_attach_stream_to_voice" id="TOC-al_attach_stream_to_voice"
	      >al_attach_stream_to_voice</a
	      ></li
	    ><li
	    ><a href="#al_attach_mixer_to_voice" id="TOC-al_attach_mixer_to_voice"
	      >al_attach_mixer_to_voice</a
	      ></li
	    ><li
	    ><a href="#al_attach_sample_to_voice" id="TOC-al_attach_sample_to_voice"
	      >al_attach_sample_to_voice</a
	      ></li
	    ><li
	    ><a href="#al_get_voice_frequency" id="TOC-al_get_voice_frequency"
	      >al_get_voice_frequency</a
	      ></li
	    ><li
	    ><a href="#al_get_voice_channels" id="TOC-al_get_voice_channels"
	      >al_get_voice_channels</a
	      ></li
	    ><li
	    ><a href="#al_get_voice_depth" id="TOC-al_get_voice_depth"
	      >al_get_voice_depth</a
	      ></li
	    ><li
	    ><a href="#al_get_voice_playing" id="TOC-al_get_voice_playing"
	      >al_get_voice_playing</a
	      ></li
	    ><li
	    ><a href="#al_set_voice_playing" id="TOC-al_set_voice_playing"
	      >al_set_voice_playing</a
	      ></li
	    ><li
	    ><a href="#al_get_voice_position" id="TOC-al_get_voice_position"
	      >al_get_voice_position</a
	      ></li
	    ><li
	    ><a href="#al_set_voice_position" id="TOC-al_set_voice_position"
	      >al_set_voice_position</a
	      ></li
	    ></ul
	  ></li
	><li
	><a href="#sample-functions" id="TOC-sample-functions"
	  >Sample functions</a
	  ><ul
	  ><li
	    ><a href="#al_create_sample" id="TOC-al_create_sample"
	      >al_create_sample</a
	      ></li
	    ><li
	    ><a href="#al_destroy_sample" id="TOC-al_destroy_sample"
	      >al_destroy_sample</a
	      ></li
	    ><li
	    ><a href="#al_play_sample" id="TOC-al_play_sample"
	      >al_play_sample</a
	      ></li
	    ><li
	    ><a href="#al_stop_sample" id="TOC-al_stop_sample"
	      >al_stop_sample</a
	      ></li
	    ><li
	    ><a href="#al_stop_samples" id="TOC-al_stop_samples"
	      >al_stop_samples</a
	      ></li
	    ><li
	    ><a href="#al_create_sample_instance" id="TOC-al_create_sample_instance"
	      >al_create_sample_instance</a
	      ></li
	    ><li
	    ><a href="#al_destroy_sample_instance" id="TOC-al_destroy_sample_instance"
	      >al_destroy_sample_instance</a
	      ></li
	    ><li
	    ><a href="#al_play_sample_instance" id="TOC-al_play_sample_instance"
	      >al_play_sample_instance</a
	      ></li
	    ><li
	    ><a href="#al_stop_sample_instance" id="TOC-al_stop_sample_instance"
	      >al_stop_sample_instance</a
	      ></li
	    ><li
	    ><a href="#al_get_sample_instance_channels" id="TOC-al_get_sample_instance_channels"
	      >al_get_sample_instance_channels</a
	      ></li
	    ><li
	    ><a href="#al_get_sample_instance_depth" id="TOC-al_get_sample_instance_depth"
	      >al_get_sample_instance_depth</a
	      ></li
	    ><li
	    ><a href="#al_get_sample_instance_frequency" id="TOC-al_get_sample_instance_frequency"
	      >al_get_sample_instance_frequency</a
	      ></li
	    ><li
	    ><a href="#al_get_sample_instance_length" id="TOC-al_get_sample_instance_length"
	      >al_get_sample_instance_length</a
	      ></li
	    ><li
	    ><a href="#al_set_sample_instance_length" id="TOC-al_set_sample_instance_length"
	      >al_set_sample_instance_length</a
	      ></li
	    ><li
	    ><a href="#al_get_sample_instance_position" id="TOC-al_get_sample_instance_position"
	      >al_get_sample_instance_position</a
	      ></li
	    ><li
	    ><a href="#al_set_sample_instance_position" id="TOC-al_set_sample_instance_position"
	      >al_set_sample_instance_position</a
	      ></li
	    ><li
	    ><a href="#al_get_sample_instance_speed" id="TOC-al_get_sample_instance_speed"
	      >al_get_sample_instance_speed</a
	      ></li
	    ><li
	    ><a href="#al_set_sample_instance_speed" id="TOC-al_set_sample_instance_speed"
	      >al_set_sample_instance_speed</a
	      ></li
	    ><li
	    ><a href="#al_get_sample_instance_gain" id="TOC-al_get_sample_instance_gain"
	      >al_get_sample_instance_gain</a
	      ></li
	    ><li
	    ><a href="#al_set_sample_instance_gain" id="TOC-al_set_sample_instance_gain"
	      >al_set_sample_instance_gain</a
	      ></li
	    ><li
	    ><a href="#al_get_sample_instance_pan" id="TOC-al_get_sample_instance_pan"
	      >al_get_sample_instance_pan</a
	      ></li
	    ><li
	    ><a href="#al_set_sample_instance_pan" id="TOC-al_set_sample_instance_pan"
	      >al_set_sample_instance_pan</a
	      ></li
	    ><li
	    ><a href="#al_get_sample_instance_time" id="TOC-al_get_sample_instance_time"
	      >al_get_sample_instance_time</a
	      ></li
	    ><li
	    ><a href="#al_get_sample_instance_playmode" id="TOC-al_get_sample_instance_playmode"
	      >al_get_sample_instance_playmode</a
	      ></li
	    ><li
	    ><a href="#al_set_sample_instance_playmode" id="TOC-al_set_sample_instance_playmode"
	      >al_set_sample_instance_playmode</a
	      ></li
	    ><li
	    ><a href="#al_get_sample_instance_playing" id="TOC-al_get_sample_instance_playing"
	      >al_get_sample_instance_playing</a
	      ></li
	    ><li
	    ><a href="#al_set_sample_instance_playing" id="TOC-al_set_sample_instance_playing"
	      >al_set_sample_instance_playing</a
	      ></li
	    ><li
	    ><a href="#al_get_sample_instance_attached" id="TOC-al_get_sample_instance_attached"
	      >al_get_sample_instance_attached</a
	      ></li
	    ><li
	    ><a href="#al_detach_sample_instance" id="TOC-al_detach_sample_instance"
	      >al_detach_sample_instance</a
	      ></li
	    ><li
	    ><a href="#al_get_sample" id="TOC-al_get_sample"
	      >al_get_sample</a
	      ></li
	    ><li
	    ><a href="#al_set_sample" id="TOC-al_set_sample"
	      >al_set_sample</a
	      ></li
	    ></ul
	  ></li
	><li
	><a href="#mixer-functions" id="TOC-mixer-functions"
	  >Mixer functions</a
	  ><ul
	  ><li
	    ><a href="#al_create_mixer" id="TOC-al_create_mixer"
	      >al_create_mixer</a
	      ></li
	    ><li
	    ><a href="#al_destroy_mixer" id="TOC-al_destroy_mixer"
	      >al_destroy_mixer</a
	      ></li
	    ><li
	    ><a href="#al_get_default_mixer" id="TOC-al_get_default_mixer"
	      >al_get_default_mixer</a
	      ></li
	    ><li
	    ><a href="#al_set_default_mixer" id="TOC-al_set_default_mixer"
	      >al_set_default_mixer</a
	      ></li
	    ><li
	    ><a href="#al_restore_default_mixer" id="TOC-al_restore_default_mixer"
	      >al_restore_default_mixer</a
	      ></li
	    ><li
	    ><a href="#al_attach_mixer_to_mixer" id="TOC-al_attach_mixer_to_mixer"
	      >al_attach_mixer_to_mixer</a
	      ></li
	    ><li
	    ><a href="#al_attach_sample_to_mixer" id="TOC-al_attach_sample_to_mixer"
	      >al_attach_sample_to_mixer</a
	      ></li
	    ><li
	    ><a href="#al_attach_stream_to_mixer" id="TOC-al_attach_stream_to_mixer"
	      >al_attach_stream_to_mixer</a
	      ></li
	    ><li
	    ><a href="#al_get_mixer_frequency" id="TOC-al_get_mixer_frequency"
	      >al_get_mixer_frequency</a
	      ></li
	    ><li
	    ><a href="#al_set_mixer_frequency" id="TOC-al_set_mixer_frequency"
	      >al_set_mixer_frequency</a
	      ></li
	    ><li
	    ><a href="#al_get_mixer_channels" id="TOC-al_get_mixer_channels"
	      >al_get_mixer_channels</a
	      ></li
	    ><li
	    ><a href="#al_get_mixer_depth" id="TOC-al_get_mixer_depth"
	      >al_get_mixer_depth</a
	      ></li
	    ><li
	    ><a href="#al_get_mixer_quality" id="TOC-al_get_mixer_quality"
	      >al_get_mixer_quality</a
	      ></li
	    ><li
	    ><a href="#al_set_mixer_quality" id="TOC-al_set_mixer_quality"
	      >al_set_mixer_quality</a
	      ></li
	    ><li
	    ><a href="#al_get_mixer_playing" id="TOC-al_get_mixer_playing"
	      >al_get_mixer_playing</a
	      ></li
	    ><li
	    ><a href="#al_set_mixer_playing" id="TOC-al_set_mixer_playing"
	      >al_set_mixer_playing</a
	      ></li
	    ><li
	    ><a href="#al_get_mixer_attached" id="TOC-al_get_mixer_attached"
	      >al_get_mixer_attached</a
	      ></li
	    ><li
	    ><a href="#al_detach_mixer" id="TOC-al_detach_mixer"
	      >al_detach_mixer</a
	      ></li
	    ><li
	    ><a href="#al_set_mixer_postprocess_callback" id="TOC-al_set_mixer_postprocess_callback"
	      >al_set_mixer_postprocess_callback</a
	      ></li
	    ></ul
	  ></li
	><li
	><a href="#stream-functions" id="TOC-stream-functions"
	  >Stream functions</a
	  ><ul
	  ><li
	    ><a href="#al_create_stream" id="TOC-al_create_stream"
	      >al_create_stream</a
	      ></li
	    ><li
	    ><a href="#al_destroy_stream" id="TOC-al_destroy_stream"
	      >al_destroy_stream</a
	      ></li
	    ><li
	    ><a href="#al_drain_stream" id="TOC-al_drain_stream"
	      >al_drain_stream</a
	      ></li
	    ><li
	    ><a href="#al_rewind_stream" id="TOC-al_rewind_stream"
	      >al_rewind_stream</a
	      ></li
	    ><li
	    ><a href="#al_get_stream_frequency" id="TOC-al_get_stream_frequency"
	      >al_get_stream_frequency</a
	      ></li
	    ><li
	    ><a href="#al_get_stream_channels" id="TOC-al_get_stream_channels"
	      >al_get_stream_channels</a
	      ></li
	    ><li
	    ><a href="#al_get_stream_depth" id="TOC-al_get_stream_depth"
	      >al_get_stream_depth</a
	      ></li
	    ><li
	    ><a href="#al_get_stream_length" id="TOC-al_get_stream_length"
	      >al_get_stream_length</a
	      ></li
	    ><li
	    ><a href="#al_get_stream_speed" id="TOC-al_get_stream_speed"
	      >al_get_stream_speed</a
	      ></li
	    ><li
	    ><a href="#al_set_stream_speed" id="TOC-al_set_stream_speed"
	      >al_set_stream_speed</a
	      ></li
	    ><li
	    ><a href="#al_get_stream_gain" id="TOC-al_get_stream_gain"
	      >al_get_stream_gain</a
	      ></li
	    ><li
	    ><a href="#al_set_stream_gain" id="TOC-al_set_stream_gain"
	      >al_set_stream_gain</a
	      ></li
	    ><li
	    ><a href="#al_get_stream_pan" id="TOC-al_get_stream_pan"
	      >al_get_stream_pan</a
	      ></li
	    ><li
	    ><a href="#al_set_stream_pan" id="TOC-al_set_stream_pan"
	      >al_set_stream_pan</a
	      ></li
	    ><li
	    ><a href="#al_get_stream_playing" id="TOC-al_get_stream_playing"
	      >al_get_stream_playing</a
	      ></li
	    ><li
	    ><a href="#al_set_stream_playing" id="TOC-al_set_stream_playing"
	      >al_set_stream_playing</a
	      ></li
	    ><li
	    ><a href="#al_get_stream_playmode" id="TOC-al_get_stream_playmode"
	      >al_get_stream_playmode</a
	      ></li
	    ><li
	    ><a href="#al_set_stream_playmode" id="TOC-al_set_stream_playmode"
	      >al_set_stream_playmode</a
	      ></li
	    ><li
	    ><a href="#al_get_stream_attached" id="TOC-al_get_stream_attached"
	      >al_get_stream_attached</a
	      ></li
	    ><li
	    ><a href="#al_detach_stream" id="TOC-al_detach_stream"
	      >al_detach_stream</a
	      ></li
	    ><li
	    ><a href="#al_get_stream_buffer" id="TOC-al_get_stream_buffer"
	      >al_get_stream_buffer</a
	      ></li
	    ><li
	    ><a href="#al_set_stream_buffer" id="TOC-al_set_stream_buffer"
	      >al_set_stream_buffer</a
	      ></li
	    ><li
	    ><a href="#al_get_stream_fragments" id="TOC-al_get_stream_fragments"
	      >al_get_stream_fragments</a
	      ></li
	    ><li
	    ><a href="#al_get_stream_used_fragments" id="TOC-al_get_stream_used_fragments"
	      >al_get_stream_used_fragments</a
	      ></li
	    ><li
	    ><a href="#al_seek_stream_secs" id="TOC-al_seek_stream_secs"
	      >al_seek_stream_secs</a
	      ></li
	    ><li
	    ><a href="#al_get_stream_position_secs" id="TOC-al_get_stream_position_secs"
	      >al_get_stream_position_secs</a
	      ></li
	    ><li
	    ><a href="#al_get_stream_length_secs" id="TOC-al_get_stream_length_secs"
	      >al_get_stream_length_secs</a
	      ></li
	    ><li
	    ><a href="#al_set_stream_loop_secs" id="TOC-al_set_stream_loop_secs"
	      >al_set_stream_loop_secs</a
	      ></li
	    ></ul
	  ></li
	></ul
      ></div
    ><h1 id="audio-types"
    ><a href="#TOC-audio-types"
      >Audio types</a
      ></h1
    ><h2 id="allegro_audio_depth"
    ><a href="#TOC-allegro_audio_depth"
      >ALLEGRO_AUDIO_DEPTH</a
      ></h2
    ><pre
    ><code
      >enum ALLEGRO_AUDIO_DEPTH {
</code
      ></pre
    ><p
    >Sample depth and type, and signedness. Mixers only use 32-bit signed float (-1..+1). The unsigned value is a bit-flag applied to the depth value.</p
    ><ul
    ><li
      >ALLEGRO_AUDIO_DEPTH_INT8</li
      ><li
      >ALLEGRO_AUDIO_DEPTH_INT16</li
      ><li
      >ALLEGRO_AUDIO_DEPTH_INT24</li
      ><li
      >ALLEGRO_AUDIO_DEPTH_FLOAT32</li
      ><li
      >ALLEGRO_AUDIO_DEPTH_UNSIGNED</li
      ></ul
    ><p
    >For convenience:</p
    ><ul
    ><li
      >ALLEGRO_AUDIO_DEPTH_UINT8</li
      ><li
      >ALLEGRO_AUDIO_DEPTH_UINT16</li
      ><li
      >ALLEGRO_AUDIO_DEPTH_UINT24</li
      ></ul
    ><h2 id="allegro_audio_driver_enum"
    ><a href="#TOC-allegro_audio_driver_enum"
      >ALLEGRO_AUDIO_DRIVER_ENUM</a
      ></h2
    ><pre
    ><code
      >enum ALLEGRO_AUDIO_DRIVER_ENUM {
</code
      ></pre
    ><p
    >The sound driver to use. It is <em
      >highly</em
      > recommended to use ALLEGRO_AUDIO_DRIVER_AUTODETECT whenever possible.</p
    ><ul
    ><li
      >ALLEGRO_AUDIO_DRIVER_AUTODETECT</li
      ><li
      >ALLEGRO_AUDIO_DRIVER_OPENAL</li
      ><li
      >ALLEGRO_AUDIO_DRIVER_ALSA</li
      ><li
      >ALLEGRO_AUDIO_DRIVER_DSOUND</li
      ><li
      >ALLEGRO_AUDIO_DRIVER_OSS</li
      ></ul
    ><h2 id="allegro_audio_pan_none"
    ><a href="#TOC-allegro_audio_pan_none"
      >ALLEGRO_AUDIO_PAN_NONE</a
      ></h2
    ><pre
    ><code
      >#define ALLEGRO_AUDIO_PAN_NONE      (-1000.0f)
</code
      ></pre
    ><p
    >Special value for the ALLEGRO_AUDIOPROP_PAN property. Use this value to play samples at their original volume with panning disabled.</p
    ><h2 id="allegro_channel_conf"
    ><a href="#TOC-allegro_channel_conf"
      >ALLEGRO_CHANNEL_CONF</a
      ></h2
    ><pre
    ><code
      >enum ALLEGRO_CHANNEL_CONF {
</code
      ></pre
    ><p
    >Speaker configuration (mono, stereo, 2.1, 3, etc).</p
    ><ul
    ><li
      >ALLEGRO_CHANNEL_CONF_1</li
      ><li
      >ALLEGRO_CHANNEL_CONF_2</li
      ><li
      >ALLEGRO_CHANNEL_CONF_3</li
      ><li
      >ALLEGRO_CHANNEL_CONF_4</li
      ><li
      >ALLEGRO_CHANNEL_CONF_5_1</li
      ><li
      >ALLEGRO_CHANNEL_CONF_6_1</li
      ><li
      >ALLEGRO_CHANNEL_CONF_7_1</li
      ></ul
    ><h2 id="allegro_mixer"
    ><a href="#TOC-allegro_mixer"
      >ALLEGRO_MIXER</a
      ></h2
    ><pre
    ><code
      >typedef struct ALLEGRO_MIXER ALLEGRO_MIXER;
</code
      ></pre
    ><p
    >A mixer is a type of stream which mixes together attached streams into a single buffer.</p
    ><h2 id="allegro_mixer_quality"
    ><a href="#TOC-allegro_mixer_quality"
      >ALLEGRO_MIXER_QUALITY</a
      ></h2
    ><pre
    ><code
      >enum ALLEGRO_MIXER_QUALITY {
</code
      ></pre
    ><ul
    ><li
      >ALLEGRO_MIXER_QUALITY_POINT</li
      ><li
      >ALLEGRO_MIXER_QUALITY_LINEAR</li
      ></ul
    ><h2 id="allegro_playmode"
    ><a href="#TOC-allegro_playmode"
      >ALLEGRO_PLAYMODE</a
      ></h2
    ><pre
    ><code
      >enum ALLEGRO_PLAYMODE {
</code
      ></pre
    ><p
    >Sample and stream looping mode.</p
    ><ul
    ><li
      >ALLEGRO_PLAYMODE_ONCE</li
      ><li
      >ALLEGRO_PLAYMODE_LOOP</li
      ><li
      >ALLEGRO_PLAYMODE_BIDIR</li
      ></ul
    ><h2 id="allegro_sample_id"
    ><a href="#TOC-allegro_sample_id"
      >ALLEGRO_SAMPLE_ID</a
      ></h2
    ><pre
    ><code
      >typedef struct {
</code
      ></pre
    ><p
    >An ALLEGRO_SAMPLE_ID represents a sample being played via <a href="kcm_audio.html#al_play_sample"
      >al_play_sample</a
      >. It can be used to later stop the sample with <a href="kcm_audio.html#al_stop_sample"
      >al_stop_sample</a
      >.</p
    ><h2 id="allegro_sample"
    ><a href="#TOC-allegro_sample"
      >ALLEGRO_SAMPLE</a
      ></h2
    ><pre
    ><code
      >typedef struct ALLEGRO_SAMPLE ALLEGRO_SAMPLE;
</code
      ></pre
    ><p
    >An ALLEGRO_SAMPLE object stores the data necessary for playing pre-defined digital audio. It holds information pertaining to data length, frequency, channel configuration, etc. You can have an ALLEGRO_SAMPLE object playing multiple times simultaneously. The object holds a user-specified PCM data buffer, of the format the object is created with.</p
    ><h2 id="allegro_sample_instance"
    ><a href="#TOC-allegro_sample_instance"
      >ALLEGRO_SAMPLE_INSTANCE</a
      ></h2
    ><pre
    ><code
      >typedef struct ALLEGRO_SAMPLE_INSTANCE ALLEGRO_SAMPLE_INSTANCE;
</code
      ></pre
    ><p
    >An ALLEGRO_SAMPLE_INSTANCE object represents a playable instance of a predefined sound effect. It holds information pertaining to the looping mode, loop start/end points, playing position, etc. An instance uses the data from an <a href="kcm_audio.html#allegro_sample"
      >ALLEGRO_SAMPLE</a
      > object. Multiple instances may be created from the same ALLEGRO_SAMPLE. An ALLEGRO_SAMPLE must not be destroyed while there are instances which reference it.</p
    ><p
    >To be played, an ALLEGRO_SAMPLE_INSTANCE object must be attached to an <a href="kcm_audio.html#allegro_voice"
      >ALLEGRO_VOICE</a
      > object, or to an <a href="kcm_audio.html#allegro_mixer"
      >ALLEGRO_MIXER</a
      > object which is itself attached to an ALLEGRO_VOICE object (or to another ALLEGRO_MIXER object which is attached to an ALLEGRO_VOICE object, etc).</p
    ><h2 id="allegro_stream"
    ><a href="#TOC-allegro_stream"
      >ALLEGRO_STREAM</a
      ></h2
    ><pre
    ><code
      >typedef struct ALLEGRO_STREAM ALLEGRO_STREAM;
</code
      ></pre
    ><p
    >An ALLEGRO_STREAM object is used to stream generated audio to the sound device, in real-time. As with <a href="kcm_audio.html#allegro_sample_instance"
      >ALLEGRO_SAMPLE_INSTANCE</a
      > objects, they store information necessary for playback, so you may not play one multiple times simultaneously. They also need to be attached to an <a href="kcm_audio.html#allegro_voice"
      >ALLEGRO_VOICE</a
      > object, or to an <a href="kcm_audio.html#allegro_mixer"
      >ALLEGRO_MIXER</a
      > object which, eventually, reaches an ALLEGRO_VOICE object.</p
    ><p
    >While playing, you must periodically supply new buffer data by first checking ALLEGRO_AUDIOPROP_USED_FRAGMENTS, then refilling the buffers via ALLEGRO_AUDIOPROP_BUFFER. If you're late with supplying new data, the object will be silenced until new data is provided. You must call <a href="kcm_audio.html#al_drain_stream"
      >al_drain_stream</a
      > when you're finished supplying the stream.</p
    ><h2 id="allegro_voice"
    ><a href="#TOC-allegro_voice"
      >ALLEGRO_VOICE</a
      ></h2
    ><pre
    ><code
      >typedef struct ALLEGRO_VOICE ALLEGRO_VOICE;
</code
      ></pre
    ><p
    >A voice structure that you'd attach a mixer or sample to. Ideally there would be one ALLEGRO_VOICE per system/hardware voice.</p
    ><h1 id="setting-up"
    ><a href="#TOC-setting-up"
      >Setting up</a
      ></h1
    ><h2 id="al_install_audio"
    ><a href="#TOC-al_install_audio"
      >al_install_audio</a
      ></h2
    ><pre
    ><code
      >bool al_install_audio(ALLEGRO_AUDIO_DRIVER_ENUM mode)
</code
      ></pre
    ><p
    >Parameters:</p
    ><ul
    ><li
      >mode - see <a href="kcm_audio.html#allegro_audio_driver_enum"
	>ALLEGRO_AUDIO_DRIVER_ENUM</a
	></li
      ></ul
    ><p
    >Returns true on success, false on failure.</p
    ><p
    ><em
      >See also:</em
      > <a href="kcm_audio.html#al_reserve_samples"
      >al_reserve_samples</a
      >.</p
    ><h2 id="al_uninstall_audio"
    ><a href="#TOC-al_uninstall_audio"
      >al_uninstall_audio</a
      ></h2
    ><pre
    ><code
      >void al_uninstall_audio(void)
</code
      ></pre
    ><h2 id="al_reserve_samples"
    ><a href="#TOC-al_reserve_samples"
      >al_reserve_samples</a
      ></h2
    ><pre
    ><code
      >bool al_reserve_samples(int reserve_samples)
</code
      ></pre
    ><p
    >Reserves 'reserve_samples' number of samples attached to the default mixer. <a href="kcm_audio.html#al_install_audio"
      >al_install_audio</a
      > must have been called first. If no default mixer is set, then this function will create a voice with an attached mixer. Returns true on success, false on error.</p
    ><h1 id="voice-functions"
    ><a href="#TOC-voice-functions"
      >Voice functions</a
      ></h1
    ><h2 id="al_create_voice"
    ><a href="#TOC-al_create_voice"
      >al_create_voice</a
      ></h2
    ><pre
    ><code
      >ALLEGRO_VOICE *al_create_voice(unsigned long freq,
   ALLEGRO_AUDIO_DEPTH depth, ALLEGRO_CHANNEL_CONF chan_conf)
</code
      ></pre
    ><p
    >Creates a voice struct and allocates a voice from the digital sound driver. The sound driver's allocate_voice function should change the voice's frequency, depth, chan_conf, and settings fields to match what is actually allocated. If it cannot create a voice with exact settings it will fail. Use a mixer in such a case.</p
    ><h2 id="al_destroy_voice"
    ><a href="#TOC-al_destroy_voice"
      >al_destroy_voice</a
      ></h2
    ><pre
    ><code
      >void al_destroy_voice(ALLEGRO_VOICE *voice)
</code
      ></pre
    ><p
    >Destroys the voice and deallocates it from the digital driver. Does nothing if the voice is NULL.</p
    ><h2 id="al_detach_voice"
    ><a href="#TOC-al_detach_voice"
      >al_detach_voice</a
      ></h2
    ><pre
    ><code
      >void al_detach_voice(ALLEGRO_VOICE *voice)
</code
      ></pre
    ><p
    >Detaches the sample or mixer stream from the voice.</p
    ><h2 id="al_attach_stream_to_voice"
    ><a href="#TOC-al_attach_stream_to_voice"
      >al_attach_stream_to_voice</a
      ></h2
    ><pre
    ><code
      >bool al_attach_stream_to_voice(ALLEGRO_VOICE *voice, ALLEGRO_STREAM *stream)
</code
      ></pre
    ><p
    >Attaches an audio stream to a voice. The same rules as <a href="kcm_audio.html#al_attach_sample_to_voice"
      >al_attach_sample_to_voice</a
      > apply. This may fail if the driver can't create a voice with the buffer count and buffer size the stream uses.</p
    ><h2 id="al_attach_mixer_to_voice"
    ><a href="#TOC-al_attach_mixer_to_voice"
      >al_attach_mixer_to_voice</a
      ></h2
    ><pre
    ><code
      >bool al_attach_mixer_to_voice(ALLEGRO_VOICE *voice, ALLEGRO_MIXER *mixer)
</code
      ></pre
    ><p
    >Attaches a mixer to a voice. The same rules as <a href="kcm_audio.html#al_attach_sample_to_voice"
      >al_attach_sample_to_voice</a
      > apply, with the exception of the depth requirement.</p
    ><h2 id="al_attach_sample_to_voice"
    ><a href="#TOC-al_attach_sample_to_voice"
      >al_attach_sample_to_voice</a
      ></h2
    ><pre
    ><code
      >bool al_attach_sample_to_voice(ALLEGRO_VOICE *voice, ALLEGRO_SAMPLE_INSTANCE *spl)
</code
      ></pre
    ><p
    >Attaches a sample to a voice, and allows it to play. The sample's volume and loop mode will be ignored, and it must have the same frequency and depth (including signed-ness) as the voice. This function may fail if the selected driver doesn't support preloading sample data.</p
    ><h2 id="al_get_voice_frequency"
    ><a href="#TOC-al_get_voice_frequency"
      >al_get_voice_frequency</a
      ></h2
    ><pre
    ><code
      >unsigned int al_get_voice_frequency(const ALLEGRO_VOICE *voice)
</code
      ></pre
    ><p
    >Return the frequency of the voice, e.g. 44100.</p
    ><h2 id="al_get_voice_channels"
    ><a href="#TOC-al_get_voice_channels"
      >al_get_voice_channels</a
      ></h2
    ><pre
    ><code
      >ALLEGRO_CHANNEL_CONF al_get_voice_channels(const ALLEGRO_VOICE *voice)
</code
      ></pre
    ><p
    >Return the channel configuration of the voice.</p
    ><p
    >See also: <a href="kcm_audio.html#allegro_channel_conf"
      >ALLEGRO_CHANNEL_CONF</a
      >.</p
    ><h2 id="al_get_voice_depth"
    ><a href="#TOC-al_get_voice_depth"
      >al_get_voice_depth</a
      ></h2
    ><pre
    ><code
      >ALLEGRO_AUDIO_DEPTH al_get_voice_depth(const ALLEGRO_VOICE *voice)
</code
      ></pre
    ><p
    >Return the audio depth of the voice.</p
    ><p
    >See also: <a href="kcm_audio.html#allegro_audio_depth"
      >ALLEGRO_AUDIO_DEPTH</a
      >.</p
    ><h2 id="al_get_voice_playing"
    ><a href="#TOC-al_get_voice_playing"
      >al_get_voice_playing</a
      ></h2
    ><pre
    ><code
      >bool al_get_voice_playing(const ALLEGRO_VOICE *voice)
</code
      ></pre
    ><p
    >Return true if the voice is currently playing.</p
    ><h2 id="al_set_voice_playing"
    ><a href="#TOC-al_set_voice_playing"
      >al_set_voice_playing</a
      ></h2
    ><pre
    ><code
      >bool al_set_voice_playing(ALLEGRO_VOICE *voice, bool val)
</code
      ></pre
    ><p
    >Change whether a voice is playing or not. The voice must have a sample or mixer attached to it.</p
    ><p
    >Returns true on success, false on failure.</p
    ><h2 id="al_get_voice_position"
    ><a href="#TOC-al_get_voice_position"
      >al_get_voice_position</a
      ></h2
    ><pre
    ><code
      >unsigned long al_get_voice_position(const ALLEGRO_VOICE *voice)
</code
      ></pre
    ><p
    >When the voice has a non-streaming object attached to it, e.g. a sample, returns the voice's current sample position. Otherwise, returns zero.</p
    ><h2 id="al_set_voice_position"
    ><a href="#TOC-al_set_voice_position"
      >al_set_voice_position</a
      ></h2
    ><pre
    ><code
      >bool al_set_voice_position(ALLEGRO_VOICE *voice, unsigned long val)
</code
      ></pre
    ><p
    >Set the voice position. This can only work if the voice has a non-streaming object attached to it, e.g. a sample.</p
    ><p
    >Returns true on success, false on failure.</p
    ><h1 id="sample-functions"
    ><a href="#TOC-sample-functions"
      >Sample functions</a
      ></h1
    ><h2 id="al_create_sample"
    ><a href="#TOC-al_create_sample"
      >al_create_sample</a
      ></h2
    ><pre
    ><code
      >ALLEGRO_SAMPLE *al_create_sample(void *buf, unsigned long samples,
   unsigned long freq, ALLEGRO_AUDIO_DEPTH depth,
   ALLEGRO_CHANNEL_CONF chan_conf, bool free_buf)
</code
      ></pre
    ><p
    >Create a sample data structure from the supplied buffer. If <code
      >free_buf</code
      > is true then the buffer will be freed as well when the sample data structure is destroyed.</p
    ><h2 id="al_destroy_sample"
    ><a href="#TOC-al_destroy_sample"
      >al_destroy_sample</a
      ></h2
    ><pre
    ><code
      >void al_destroy_sample(ALLEGRO_SAMPLE *spl)
</code
      ></pre
    ><p
    >Free the sample data structure. If it was created with the <code
      >free_buf</code
      > parameter set to true, then the buffer will be freed as well.</p
    ><p
    >You must destroy any <a href="kcm_audio.html#allegro_sample_instance"
      >ALLEGRO_SAMPLE_INSTANCE</a
      > structures which reference this ALLEGRO_SAMPLE beforehand.</p
    ><h2 id="al_play_sample"
    ><a href="#TOC-al_play_sample"
      >al_play_sample</a
      ></h2
    ><pre
    ><code
      >bool al_play_sample(ALLEGRO_SAMPLE *spl, float gain, float pan, float speed,
   int loop, ALLEGRO_SAMPLE_ID *ret_id)
</code
      ></pre
    ><p
    >Plays a sample over the default mixer. <a href="kcm_audio.html#al_reserve_samples"
      >al_reserve_samples</a
      > must have previously been called. Returns true on success, false on failure. Playback may fail because all the reserved samples are currently used.</p
    ><h2 id="al_stop_sample"
    ><a href="#TOC-al_stop_sample"
      >al_stop_sample</a
      ></h2
    ><pre
    ><code
      >void al_stop_sample(ALLEGRO_SAMPLE_ID *spl_id)
</code
      ></pre
    ><p
    >Stop the sample started by <a href="kcm_audio.html#al_play_sample"
      >al_play_sample</a
      >.</p
    ><h2 id="al_stop_samples"
    ><a href="#TOC-al_stop_samples"
      >al_stop_samples</a
      ></h2
    ><pre
    ><code
      >void al_stop_samples(void)
</code
      ></pre
    ><p
    >Stop all samples started by <a href="kcm_audio.html#al_play_sample"
      >al_play_sample</a
      >.</p
    ><h2 id="al_create_sample_instance"
    ><a href="#TOC-al_create_sample_instance"
      >al_create_sample_instance</a
      ></h2
    ><pre
    ><code
      >ALLEGRO_SAMPLE_INSTANCE *al_create_sample_instance(ALLEGRO_SAMPLE *sample_data)
</code
      ></pre
    ><p
    >Creates a sample stream, using the supplied data. This must be attached to a voice or mixer before it can be played. The argument may be NULL. You can then set the data later with <a href="kcm_audio.html#al_set_sample"
      >al_set_sample</a
      >.</p
    ><h2 id="al_destroy_sample_instance"
    ><a href="#TOC-al_destroy_sample_instance"
      >al_destroy_sample_instance</a
      ></h2
    ><pre
    ><code
      >void al_destroy_sample_instance(ALLEGRO_SAMPLE_INSTANCE *spl)
</code
      ></pre
    ><p
    >Detaches the sample stream from anything it may be attached to and frees it (the sample data is <em
      >not</em
      > freed!).</p
    ><h2 id="al_play_sample_instance"
    ><a href="#TOC-al_play_sample_instance"
      >al_play_sample_instance</a
      ></h2
    ><pre
    ><code
      >bool al_play_sample_instance(ALLEGRO_SAMPLE_INSTANCE *spl)
</code
      ></pre
    ><p
    >Play an instance of a sample data. Returns true on success, false on failure.</p
    ><h2 id="al_stop_sample_instance"
    ><a href="#TOC-al_stop_sample_instance"
      >al_stop_sample_instance</a
      ></h2
    ><pre
    ><code
      >bool al_stop_sample_instance(ALLEGRO_SAMPLE_INSTANCE *spl)
</code
      ></pre
    ><p
    >Stop an sample instance playing.</p
    ><h2 id="al_get_sample_instance_channels"
    ><a href="#TOC-al_get_sample_instance_channels"
      >al_get_sample_instance_channels</a
      ></h2
    ><pre
    ><code
      >ALLEGRO_CHANNEL_CONF al_get_sample_instance_channels(
   const ALLEGRO_SAMPLE_INSTANCE *spl)
</code
      ></pre
    ><p
    >Return the channel configuration.</p
    ><p
    >See also: <a href="kcm_audio.html#allegro_channel_conf"
      >ALLEGRO_CHANNEL_CONF</a
      >.</p
    ><h2 id="al_get_sample_instance_depth"
    ><a href="#TOC-al_get_sample_instance_depth"
      >al_get_sample_instance_depth</a
      ></h2
    ><pre
    ><code
      >ALLEGRO_AUDIO_DEPTH al_get_sample_instance_depth(const ALLEGRO_SAMPLE_INSTANCE *spl)
</code
      ></pre
    ><p
    >Return the audio depth.</p
    ><p
    >See also: <a href="kcm_audio.html#allegro_audio_depth"
      >ALLEGRO_AUDIO_DEPTH</a
      >.</p
    ><h2 id="al_get_sample_instance_frequency"
    ><a href="#TOC-al_get_sample_instance_frequency"
      >al_get_sample_instance_frequency</a
      ></h2
    ><pre
    ><code
      >unsigned int al_get_sample_instance_frequency(const ALLEGRO_SAMPLE_INSTANCE *spl)
</code
      ></pre
    ><p
    >Return the frequency of the sample instance.</p
    ><h2 id="al_get_sample_instance_length"
    ><a href="#TOC-al_get_sample_instance_length"
      >al_get_sample_instance_length</a
      ></h2
    ><pre
    ><code
      >unsigned long al_get_sample_instance_length(const ALLEGRO_SAMPLE_INSTANCE *spl)
</code
      ></pre
    ><p
    >Return the length of the sample instance in sample values.</p
    ><h2 id="al_set_sample_instance_length"
    ><a href="#TOC-al_set_sample_instance_length"
      >al_set_sample_instance_length</a
      ></h2
    ><pre
    ><code
      >bool al_set_sample_instance_length(ALLEGRO_SAMPLE_INSTANCE *spl,
   unsigned long val)
</code
      ></pre
    ><p
    >Set the length of the sample instance in sample values.</p
    ><p
    >Return true on success, false on failure. Will fail if the sample instance is currently playing.</p
    ><h2 id="al_get_sample_instance_position"
    ><a href="#TOC-al_get_sample_instance_position"
      >al_get_sample_instance_position</a
      ></h2
    ><pre
    ><code
      >unsigned long al_get_sample_instance_position(const ALLEGRO_SAMPLE_INSTANCE *spl)
</code
      ></pre
    ><p
    >Get the playback position of a sample instance.</p
    ><h2 id="al_set_sample_instance_position"
    ><a href="#TOC-al_set_sample_instance_position"
      >al_set_sample_instance_position</a
      ></h2
    ><pre
    ><code
      >bool al_set_sample_instance_position(ALLEGRO_SAMPLE_INSTANCE *spl,
   unsigned long val)
</code
      ></pre
    ><p
    >Set the playback position of a sample instance.</p
    ><p
    >Returns true on success, false on failure.</p
    ><h2 id="al_get_sample_instance_speed"
    ><a href="#TOC-al_get_sample_instance_speed"
      >al_get_sample_instance_speed</a
      ></h2
    ><pre
    ><code
      >float al_get_sample_instance_speed(const ALLEGRO_SAMPLE_INSTANCE *spl)
</code
      ></pre
    ><p
    >Return the playback speed.</p
    ><h2 id="al_set_sample_instance_speed"
    ><a href="#TOC-al_set_sample_instance_speed"
      >al_set_sample_instance_speed</a
      ></h2
    ><pre
    ><code
      >bool al_set_sample_instance_speed(ALLEGRO_SAMPLE_INSTANCE *spl, float val)
</code
      ></pre
    ><p
    >Set the playback speed.</p
    ><p
    >Return true on success, false on failure. Will fail if the sample instance is attached directly to a voice.</p
    ><h2 id="al_get_sample_instance_gain"
    ><a href="#TOC-al_get_sample_instance_gain"
      >al_get_sample_instance_gain</a
      ></h2
    ><pre
    ><code
      >float al_get_sample_instance_gain(const ALLEGRO_SAMPLE_INSTANCE *spl)
</code
      ></pre
    ><p
    >Return the playback gain.</p
    ><h2 id="al_set_sample_instance_gain"
    ><a href="#TOC-al_set_sample_instance_gain"
      >al_set_sample_instance_gain</a
      ></h2
    ><pre
    ><code
      >bool al_set_sample_instance_gain(ALLEGRO_SAMPLE_INSTANCE *spl, float val)
</code
      ></pre
    ><p
    >Set the playback gain.</p
    ><p
    >Returns true on success, false on failure. Will fail if the sample instance is attached directly to a voice.</p
    ><h2 id="al_get_sample_instance_pan"
    ><a href="#TOC-al_get_sample_instance_pan"
      >al_get_sample_instance_pan</a
      ></h2
    ><pre
    ><code
      >float al_get_sample_instance_pan(const ALLEGRO_SAMPLE_INSTANCE *spl)
</code
      ></pre
    ><p
    >Get the pan value.</p
    ><h2 id="al_set_sample_instance_pan"
    ><a href="#TOC-al_set_sample_instance_pan"
      >al_set_sample_instance_pan</a
      ></h2
    ><pre
    ><code
      >bool al_set_sample_instance_pan(ALLEGRO_SAMPLE_INSTANCE *spl, float val)
</code
      ></pre
    ><p
    >Set the pan value on a sample instance. A value of -1.0 means to play the sample only through the left speaker; +1.0 means only through the right speaker; 0.0 means the sample is centre balanced.</p
    ><p
    >A constant sound power level is maintained as the sample is panned from left to right. As a consequence, a pan value of 0.0 will play the sample 3 dB softer than the original level. To disable panning and play a sample at its original level, set the pan value to <a href="kcm_audio.html#allegro_audio_pan_none"
      >ALLEGRO_AUDIO_PAN_NONE</a
      >.</p
    ><p
    >Returns true on success, false on failure. Will fail if the sample instance is attached directly to a voice.</p
    ><p
    >(A sound guy should explain that better; I only implemented it. Also this might be more properly called a balance control than pan. Also we don't attempt anything with more than two channels yet.)</p
    ><h2 id="al_get_sample_instance_time"
    ><a href="#TOC-al_get_sample_instance_time"
      >al_get_sample_instance_time</a
      ></h2
    ><pre
    ><code
      >float al_get_sample_instance_time(const ALLEGRO_SAMPLE_INSTANCE *spl)
</code
      ></pre
    ><p
    >Return the length of the sample instance in seconds, assuming a playback speed of 1.0.</p
    ><h2 id="al_get_sample_instance_playmode"
    ><a href="#TOC-al_get_sample_instance_playmode"
      >al_get_sample_instance_playmode</a
      ></h2
    ><pre
    ><code
      >ALLEGRO_PLAYMODE al_get_sample_instance_playmode(const ALLEGRO_SAMPLE_INSTANCE *spl)
</code
      ></pre
    ><p
    >Return the playback mode.</p
    ><h2 id="al_set_sample_instance_playmode"
    ><a href="#TOC-al_set_sample_instance_playmode"
      >al_set_sample_instance_playmode</a
      ></h2
    ><pre
    ><code
      >bool al_set_sample_instance_playmode(ALLEGRO_SAMPLE_INSTANCE *spl,
   ALLEGRO_PLAYMODE val)
</code
      ></pre
    ><p
    >Set the playback mode.</p
    ><p
    >Returns true on success, false on failure.</p
    ><h2 id="al_get_sample_instance_playing"
    ><a href="#TOC-al_get_sample_instance_playing"
      >al_get_sample_instance_playing</a
      ></h2
    ><pre
    ><code
      >bool al_get_sample_instance_playing(const ALLEGRO_SAMPLE_INSTANCE *spl)
</code
      ></pre
    ><p
    >Return true if the sample instance is playing.</p
    ><h2 id="al_set_sample_instance_playing"
    ><a href="#TOC-al_set_sample_instance_playing"
      >al_set_sample_instance_playing</a
      ></h2
    ><pre
    ><code
      >bool al_set_sample_instance_playing(ALLEGRO_SAMPLE_INSTANCE *spl, bool val)
</code
      ></pre
    ><p
    >Change whether the sample instance is playing.</p
    ><p
    >Returns true on success, false on failure.</p
    ><h2 id="al_get_sample_instance_attached"
    ><a href="#TOC-al_get_sample_instance_attached"
      >al_get_sample_instance_attached</a
      ></h2
    ><pre
    ><code
      >bool al_get_sample_instance_attached(const ALLEGRO_SAMPLE_INSTANCE *spl)
</code
      ></pre
    ><p
    >Return whether the sample instance is attached to something.</p
    ><h2 id="al_detach_sample_instance"
    ><a href="#TOC-al_detach_sample_instance"
      >al_detach_sample_instance</a
      ></h2
    ><pre
    ><code
      >bool al_detach_sample_instance(ALLEGRO_SAMPLE_INSTANCE *spl)
</code
      ></pre
    ><p
    >Detach the sample instance from whatever it's attached to, if anything.</p
    ><h2 id="al_get_sample"
    ><a href="#TOC-al_get_sample"
      >al_get_sample</a
      ></h2
    ><pre
    ><code
      >ALLEGRO_SAMPLE *al_get_sample(ALLEGRO_SAMPLE_INSTANCE *spl)
</code
      ></pre
    ><p
    >Return the sample data that the sample instance plays.</p
    ><h2 id="al_set_sample"
    ><a href="#TOC-al_set_sample"
      >al_set_sample</a
      ></h2
    ><pre
    ><code
      >bool al_set_sample(ALLEGRO_SAMPLE_INSTANCE *spl, ALLEGRO_SAMPLE *data)
</code
      ></pre
    ><p
    >Change the sample data that a sample instance plays. This can be quite an involved process.</p
    ><p
    >First, the sample is stopped if it is not already.</p
    ><p
    >Next, if data is NULL, the sample is detached from its parent (if any).</p
    ><p
    >If data is not NULL, the sample may be detached and reattached to its parent (if any). This is not necessary if the old sample data and new sample data have the same frequency, depth and channel configuration. Reattaching may not always succeed.</p
    ><p
    >On success, the sample remains stopped. The playback position and loop end points are reset to their default values. The loop mode remains unchanged.</p
    ><p
    >Returns true on success, false on failure. On failure, the sample will be stopped and detached from its parent.</p
    ><h1 id="mixer-functions"
    ><a href="#TOC-mixer-functions"
      >Mixer functions</a
      ></h1
    ><h2 id="al_create_mixer"
    ><a href="#TOC-al_create_mixer"
      >al_create_mixer</a
      ></h2
    ><pre
    ><code
      >ALLEGRO_MIXER *al_create_mixer(unsigned long freq,
   ALLEGRO_AUDIO_DEPTH depth, ALLEGRO_CHANNEL_CONF chan_conf)
</code
      ></pre
    ><p
    >Creates a mixer stream, to attach sample streams or other mixers to. It will mix into a buffer at the requested frequency and channel count. Only floating point mixing is currently supported.</p
    ><h2 id="al_destroy_mixer"
    ><a href="#TOC-al_destroy_mixer"
      >al_destroy_mixer</a
      ></h2
    ><pre
    ><code
      >void al_destroy_mixer(ALLEGRO_MIXER *mixer)
</code
      ></pre
    ><p
    >Destroys the mixer stream.</p
    ><h2 id="al_get_default_mixer"
    ><a href="#TOC-al_get_default_mixer"
      >al_get_default_mixer</a
      ></h2
    ><pre
    ><code
      >ALLEGRO_MIXER *al_get_default_mixer(void)
</code
      ></pre
    ><p
    >Return the default mixer.</p
    ><h2 id="al_set_default_mixer"
    ><a href="#TOC-al_set_default_mixer"
      >al_set_default_mixer</a
      ></h2
    ><pre
    ><code
      >bool al_set_default_mixer(ALLEGRO_MIXER *mixer)
</code
      ></pre
    ><p
    >Sets the default mixer. All samples started with <a href="kcm_audio.html#al_play_sample"
      >al_play_sample</a
      > will be stopped. If you are using your own mixer, this should be called before <a href="kcm_audio.html#al_reserve_samples"
      >al_reserve_samples</a
      >. Returns true on success, false on error.</p
    ><h2 id="al_restore_default_mixer"
    ><a href="#TOC-al_restore_default_mixer"
      >al_restore_default_mixer</a
      ></h2
    ><pre
    ><code
      >bool al_restore_default_mixer(void)
</code
      ></pre
    ><p
    >Restores Allegro's default mixer. All samples started with <a href="kcm_audio.html#al_play_sample"
      >al_play_sample</a
      > will be stopped. Returns true on success, false on error.</p
    ><h2 id="al_attach_mixer_to_mixer"
    ><a href="#TOC-al_attach_mixer_to_mixer"
      >al_attach_mixer_to_mixer</a
      ></h2
    ><pre
    ><code
      >bool al_attach_mixer_to_mixer(ALLEGRO_MIXER *mixer, ALLEGRO_MIXER *stream)
</code
      ></pre
    ><p
    >Attaches a mixer onto another mixer. The same rules as with <a href="kcm_audio.html#al_attach_sample_to_mixer"
      >al_attach_sample_to_mixer</a
      > apply, with the added caveat that both mixers must be the same frequency.</p
    ><h2 id="al_attach_sample_to_mixer"
    ><a href="#TOC-al_attach_sample_to_mixer"
      >al_attach_sample_to_mixer</a
      ></h2
    ><pre
    ><code
      >bool al_attach_sample_to_mixer(ALLEGRO_MIXER *mixer, ALLEGRO_SAMPLE_INSTANCE *spl)
</code
      ></pre
    ><p
    >Attach a sample instance to a mixer.</p
    ><p
    >Returns true on success, false on failure.</p
    ><h2 id="al_attach_stream_to_mixer"
    ><a href="#TOC-al_attach_stream_to_mixer"
      >al_attach_stream_to_mixer</a
      ></h2
    ><pre
    ><code
      >bool al_attach_stream_to_mixer(ALLEGRO_MIXER *mixer, ALLEGRO_STREAM *stream)
</code
      ></pre
    ><p
    >Attach a stream to a mixer.</p
    ><p
    >Returns true on success, false on failure.</p
    ><h2 id="al_get_mixer_frequency"
    ><a href="#TOC-al_get_mixer_frequency"
      >al_get_mixer_frequency</a
      ></h2
    ><pre
    ><code
      >unsigned int al_get_mixer_frequency(const ALLEGRO_MIXER *mixer)
</code
      ></pre
    ><p
    >Return the mixer frequency.</p
    ><h2 id="al_set_mixer_frequency"
    ><a href="#TOC-al_set_mixer_frequency"
      >al_set_mixer_frequency</a
      ></h2
    ><pre
    ><code
      >bool al_set_mixer_frequency(ALLEGRO_MIXER *mixer, unsigned long val)
</code
      ></pre
    ><h2 id="al_get_mixer_channels"
    ><a href="#TOC-al_get_mixer_channels"
      >al_get_mixer_channels</a
      ></h2
    ><pre
    ><code
      >ALLEGRO_CHANNEL_CONF al_get_mixer_channels(const ALLEGRO_MIXER *mixer)
</code
      ></pre
    ><p
    >Return the mixer channel configuration.</p
    ><h2 id="al_get_mixer_depth"
    ><a href="#TOC-al_get_mixer_depth"
      >al_get_mixer_depth</a
      ></h2
    ><pre
    ><code
      >ALLEGRO_AUDIO_DEPTH al_get_mixer_depth(const ALLEGRO_MIXER *mixer)
</code
      ></pre
    ><p
    >Return the mixer audio depth.</p
    ><h2 id="al_get_mixer_quality"
    ><a href="#TOC-al_get_mixer_quality"
      >al_get_mixer_quality</a
      ></h2
    ><pre
    ><code
      >ALLEGRO_MIXER_QUALITY al_get_mixer_quality(const ALLEGRO_MIXER *mixer)
</code
      ></pre
    ><p
    >Return the mixer quality.</p
    ><p
    >See also: <a href="kcm_audio.html#allegro_mixer_quality"
      >ALLEGRO_MIXER_QUALITY</a
      >.</p
    ><h2 id="al_set_mixer_quality"
    ><a href="#TOC-al_set_mixer_quality"
      >al_set_mixer_quality</a
      ></h2
    ><pre
    ><code
      >bool al_set_mixer_quality(ALLEGRO_MIXER *mixer, ALLEGRO_MIXER_QUALITY val)
</code
      ></pre
    ><p
    >Set the mixer quality.</p
    ><p
    >Returns true on success, false on failure.</p
    ><h2 id="al_get_mixer_playing"
    ><a href="#TOC-al_get_mixer_playing"
      >al_get_mixer_playing</a
      ></h2
    ><pre
    ><code
      >bool al_get_mixer_playing(const ALLEGRO_MIXER *mixer)
</code
      ></pre
    ><p
    >Return true if the mixer is playing.</p
    ><h2 id="al_set_mixer_playing"
    ><a href="#TOC-al_set_mixer_playing"
      >al_set_mixer_playing</a
      ></h2
    ><pre
    ><code
      >bool al_set_mixer_playing(ALLEGRO_MIXER *mixer, bool val)
</code
      ></pre
    ><p
    >Change whether the mixer is playing.</p
    ><p
    >Returns true on success, false on failure.</p
    ><h2 id="al_get_mixer_attached"
    ><a href="#TOC-al_get_mixer_attached"
      >al_get_mixer_attached</a
      ></h2
    ><pre
    ><code
      >bool al_get_mixer_attached(const ALLEGRO_MIXER *mixer)
</code
      ></pre
    ><p
    >Return true if the mixer is attached to something.</p
    ><h2 id="al_detach_mixer"
    ><a href="#TOC-al_detach_mixer"
      >al_detach_mixer</a
      ></h2
    ><pre
    ><code
      >bool al_detach_mixer(ALLEGRO_MIXER *mixer)
</code
      ></pre
    ><p
    >Detach the mixer from whatever it is attached to, if anything.</p
    ><h2 id="al_set_mixer_postprocess_callback"
    ><a href="#TOC-al_set_mixer_postprocess_callback"
      >al_set_mixer_postprocess_callback</a
      ></h2
    ><pre
    ><code
      >bool al_set_mixer_postprocess_callback(ALLEGRO_MIXER *mixer,
   postprocess_callback_t postprocess_callback, void *pp_callback_userdata)
</code
      ></pre
    ><p
    >Sets a post-processing filter function that's called after the attached streams have been mixed. The buffer's format will be whatever the mixer was created with. The sample count and user-data pointer is also passed.</p
    ><h1 id="stream-functions"
    ><a href="#TOC-stream-functions"
      >Stream functions</a
      ></h1
    ><h2 id="al_create_stream"
    ><a href="#TOC-al_create_stream"
      >al_create_stream</a
      ></h2
    ><pre
    ><code
      >ALLEGRO_STREAM *al_create_stream(size_t buffer_count, unsigned long samples,
   unsigned long freq, ALLEGRO_AUDIO_DEPTH depth,
   ALLEGRO_CHANNEL_CONF chan_conf)
</code
      ></pre
    ><p
    >Creates an audio stream, using the supplied values. The stream will be set to play by default.</p
    ><h2 id="al_destroy_stream"
    ><a href="#TOC-al_destroy_stream"
      >al_destroy_stream</a
      ></h2
    ><pre
    ><code
      >void al_destroy_stream(ALLEGRO_STREAM *stream)
</code
      ></pre
    ><h2 id="al_drain_stream"
    ><a href="#TOC-al_drain_stream"
      >al_drain_stream</a
      ></h2
    ><pre
    ><code
      >void al_drain_stream(ALLEGRO_STREAM *stream)
</code
      ></pre
    ><p
    >Called by the user if sample data is not going to be passed to the stream any longer. This function waits for all pending buffers to finish playing. Stream's playing state will change to false.</p
    ><h2 id="al_rewind_stream"
    ><a href="#TOC-al_rewind_stream"
      >al_rewind_stream</a
      ></h2
    ><pre
    ><code
      >bool al_rewind_stream(ALLEGRO_STREAM *stream)
</code
      ></pre
    ><p
    >Set the streaming file playing position to the beginning. Returns true on success. Currently this can only be called on streams created with acodec's <a href="acodec.html#al_stream_from_file"
      >al_stream_from_file</a
      >.</p
    ><h2 id="al_get_stream_frequency"
    ><a href="#TOC-al_get_stream_frequency"
      >al_get_stream_frequency</a
      ></h2
    ><pre
    ><code
      >unsigned int al_get_stream_frequency(const ALLEGRO_STREAM *stream)
</code
      ></pre
    ><p
    >Return the stream frequency.</p
    ><h2 id="al_get_stream_channels"
    ><a href="#TOC-al_get_stream_channels"
      >al_get_stream_channels</a
      ></h2
    ><pre
    ><code
      >ALLEGRO_CHANNEL_CONF al_get_stream_channels(const ALLEGRO_STREAM *stream)
</code
      ></pre
    ><p
    >Return the stream channel configuration.</p
    ><h2 id="al_get_stream_depth"
    ><a href="#TOC-al_get_stream_depth"
      >al_get_stream_depth</a
      ></h2
    ><pre
    ><code
      >ALLEGRO_AUDIO_DEPTH al_get_stream_depth(const ALLEGRO_STREAM *stream)
</code
      ></pre
    ><p
    >Return the stream audio depth.</p
    ><h2 id="al_get_stream_length"
    ><a href="#TOC-al_get_stream_length"
      >al_get_stream_length</a
      ></h2
    ><pre
    ><code
      >unsigned long al_get_stream_length(const ALLEGRO_STREAM *stream)
</code
      ></pre
    ><h2 id="al_get_stream_speed"
    ><a href="#TOC-al_get_stream_speed"
      >al_get_stream_speed</a
      ></h2
    ><pre
    ><code
      >float al_get_stream_speed(const ALLEGRO_STREAM *stream)
</code
      ></pre
    ><p
    >Return the playback speed.</p
    ><h2 id="al_set_stream_speed"
    ><a href="#TOC-al_set_stream_speed"
      >al_set_stream_speed</a
      ></h2
    ><pre
    ><code
      >bool al_set_stream_speed(ALLEGRO_STREAM *stream, float val)
</code
      ></pre
    ><p
    >Set the playback speed.</p
    ><p
    >Return true on success, false on failure. Will fail if the sample instance is attached directly to a voice.</p
    ><h2 id="al_get_stream_gain"
    ><a href="#TOC-al_get_stream_gain"
      >al_get_stream_gain</a
      ></h2
    ><pre
    ><code
      >float al_get_stream_gain(const ALLEGRO_STREAM *stream)
</code
      ></pre
    ><p
    >Return the playback gain.</p
    ><h2 id="al_set_stream_gain"
    ><a href="#TOC-al_set_stream_gain"
      >al_set_stream_gain</a
      ></h2
    ><pre
    ><code
      >bool al_set_stream_gain(ALLEGRO_STREAM *stream, float val)
</code
      ></pre
    ><p
    >Set the playback gain.</p
    ><p
    >Returns true on success, false on failure. Will fail if the sample instance is attached directly to a voice.</p
    ><h2 id="al_get_stream_pan"
    ><a href="#TOC-al_get_stream_pan"
      >al_get_stream_pan</a
      ></h2
    ><pre
    ><code
      >float al_get_stream_pan(const ALLEGRO_STREAM *stream)
</code
      ></pre
    ><p
    >Get the pan value.</p
    ><h2 id="al_set_stream_pan"
    ><a href="#TOC-al_set_stream_pan"
      >al_set_stream_pan</a
      ></h2
    ><pre
    ><code
      >bool al_set_stream_pan(ALLEGRO_STREAM *stream, float val)
</code
      ></pre
    ><p
    >Set the pan value on a sample instance. A value of -1.0 means to play the sample only through the left speaker; +1.0 means only through the right speaker; 0.0 means the sample is centre balanced.</p
    ><p
    >Returns true on success, false on failure. Will fail if the sample instance is attached directly to a voice.</p
    ><h2 id="al_get_stream_playing"
    ><a href="#TOC-al_get_stream_playing"
      >al_get_stream_playing</a
      ></h2
    ><pre
    ><code
      >bool al_get_stream_playing(const ALLEGRO_STREAM *stream)
</code
      ></pre
    ><p
    >Return true if the stream is playing.</p
    ><h2 id="al_set_stream_playing"
    ><a href="#TOC-al_set_stream_playing"
      >al_set_stream_playing</a
      ></h2
    ><pre
    ><code
      >bool al_set_stream_playing(ALLEGRO_STREAM *stream, bool val)
</code
      ></pre
    ><p
    >Change whether the stream is playing.</p
    ><p
    >Returns true on success, false on failure.</p
    ><h2 id="al_get_stream_playmode"
    ><a href="#TOC-al_get_stream_playmode"
      >al_get_stream_playmode</a
      ></h2
    ><pre
    ><code
      >ALLEGRO_PLAYMODE al_get_stream_playmode(const ALLEGRO_STREAM *stream)
</code
      ></pre
    ><p
    >Return the playback mode.</p
    ><h2 id="al_set_stream_playmode"
    ><a href="#TOC-al_set_stream_playmode"
      >al_set_stream_playmode</a
      ></h2
    ><pre
    ><code
      >bool al_set_stream_playmode(ALLEGRO_STREAM *stream, ALLEGRO_PLAYMODE val)
</code
      ></pre
    ><p
    >Set the playback mode.</p
    ><p
    >Returns true on success, false on failure.</p
    ><h2 id="al_get_stream_attached"
    ><a href="#TOC-al_get_stream_attached"
      >al_get_stream_attached</a
      ></h2
    ><pre
    ><code
      >bool al_get_stream_attached(const ALLEGRO_STREAM *stream)
</code
      ></pre
    ><p
    >Return whether the stream is attached to something.</p
    ><h2 id="al_detach_stream"
    ><a href="#TOC-al_detach_stream"
      >al_detach_stream</a
      ></h2
    ><pre
    ><code
      >bool al_detach_stream(ALLEGRO_STREAM *stream)
</code
      ></pre
    ><p
    >Detach the stream from whatever it's attached to, if anything.</p
    ><h2 id="al_get_stream_buffer"
    ><a href="#TOC-al_get_stream_buffer"
      >al_get_stream_buffer</a
      ></h2
    ><pre
    ><code
      >bool al_get_stream_buffer(const ALLEGRO_STREAM *stream, void **val)
</code
      ></pre
    ><h2 id="al_set_stream_buffer"
    ><a href="#TOC-al_set_stream_buffer"
      >al_set_stream_buffer</a
      ></h2
    ><pre
    ><code
      >bool al_set_stream_buffer(ALLEGRO_STREAM *stream, void *val)
</code
      ></pre
    ><h2 id="al_get_stream_fragments"
    ><a href="#TOC-al_get_stream_fragments"
      >al_get_stream_fragments</a
      ></h2
    ><pre
    ><code
      >unsigned int al_get_stream_fragments(const ALLEGRO_STREAM *stream)
</code
      ></pre
    ><h2 id="al_get_stream_used_fragments"
    ><a href="#TOC-al_get_stream_used_fragments"
      >al_get_stream_used_fragments</a
      ></h2
    ><pre
    ><code
      >unsigned int al_get_stream_used_fragments(const ALLEGRO_STREAM *stream)
</code
      ></pre
    ><h2 id="al_seek_stream_secs"
    ><a href="#TOC-al_seek_stream_secs"
      >al_seek_stream_secs</a
      ></h2
    ><pre
    ><code
      >bool al_seek_stream_secs(ALLEGRO_STREAM *stream, double time)
</code
      ></pre
    ><p
    >Set the streaming file playing position to time. Returns true on success. Currently this can only be called on streams created with acodec's <a href="acodec.html#al_stream_from_file"
      >al_stream_from_file</a
      >.</p
    ><h2 id="al_get_stream_position_secs"
    ><a href="#TOC-al_get_stream_position_secs"
      >al_get_stream_position_secs</a
      ></h2
    ><pre
    ><code
      >double al_get_stream_position_secs(ALLEGRO_STREAM *stream)
</code
      ></pre
    ><p
    >Return the position of the stream in seconds. Currently this can only be called on streams created with acodec's <a href="acodec.html#al_stream_from_file"
      >al_stream_from_file</a
      >.</p
    ><h2 id="al_get_stream_length_secs"
    ><a href="#TOC-al_get_stream_length_secs"
      >al_get_stream_length_secs</a
      ></h2
    ><pre
    ><code
      >double al_get_stream_length_secs(ALLEGRO_STREAM *stream)
</code
      ></pre
    ><p
    >Return the position of the stream in seconds. Currently this can only be called on streams created with acodec's <a href="acodec.html#al_stream_from_file"
      >al_stream_from_file</a
      >.</p
    ><h2 id="al_set_stream_loop_secs"
    ><a href="#TOC-al_set_stream_loop_secs"
      >al_set_stream_loop_secs</a
      ></h2
    ><pre
    ><code
      >bool al_set_stream_loop_secs(ALLEGRO_STREAM *stream, double start, double end)
</code
      ></pre
    ><p
    >Return the position of the stream in seconds. Currently this can only be called on streams created with acodec's <a href="acodec.html#al_stream_from_file"
      >al_stream_from_file</a
      >.</p
    ></td>
</tr>
</table>


<p>
Last updated: 2009-06-07 09:43:04 UTC
</p>
</body
  ></html
>

