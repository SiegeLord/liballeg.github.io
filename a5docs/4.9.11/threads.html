<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"
><head
  ><title
    ></title
    ><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"
     /><meta name="generator" content="pandoc"
     /><script type="text/javascript" src="autosuggest.js"></script>
<script type="text/javascript" src="search_index.js"></script>
<link rel="stylesheet" href="pandoc.css" type="text/css" media="all" />
</head
  ><body
  ><table class="white">
<tr>
<td valign="top" class="sidebar">

<div class="sidebar">
<ul
><li
  ><a href="index.html"
    >Front</a
    ></li
  ><li
  ><a href="config.html"
    >Configuration files</a
    ></li
  ><li
  ><a href="display.html"
    >Display</a
    ></li
  ><li
  ><a href="events.html"
    >Events</a
    ></li
  ><li
  ><a href="file.html"
    >File I/O</a
    ></li
  ><li
  ><a href="fshook.html"
    >Filesystem hooks</a
    ></li
  ><li
  ><a href="graphics.html"
    >Graphics</a
    ></li
  ><li
  ><a href="joystick.html"
    >Joystick</a
    ></li
  ><li
  ><a href="keyboard.html"
    >Keyboard</a
    ></li
  ><li
  ><a href="memory.html"
    >Memory</a
    ></li
  ><li
  ><a href="misc.html"
    >Miscellaneous</a
    ></li
  ><li
  ><a href="mouse.html"
    >Mouse</a
    ></li
  ><li
  ><a href="opengl.html"
    >OpenGL</a
    ></li
  ><li
  ><a href="path.html"
    >Path</a
    ></li
  ><li
  ><a href="state.html"
    >State</a
    ></li
  ><li
  ><a href="system.html"
    >System</a
    ></li
  ><li
  ><a href="threads.html"
    >Threads</a
    ></li
  ><li
  ><a href="time.html"
    >Time</a
    ></li
  ><li
  ><a href="timer.html"
    >Timer</a
    ></li
  ><li
  ><a href="utf8.html"
    >UTF-8</a
    ></li
  ><li
  ><a href="kcm_audio.html"
    >Audio addon</a
    ></li
  ><li
  ><a href="acodec.html"
    >Audio codecs</a
    ></li
  ><li
  ><a href="color.html"
    >Color addon</a
    ></li
  ><li
  ><a href="font.html"
    >Font addons</a
    ></li
  ><li
  ><a href="iio.html"
    >Image I/O addon</a
    ></li
  ><li
  ><a href="native_dialog.html"
    >Native dialogs addon</a
    ></li
  ><li
  ><a href="physfs.html"
    >PhysicsFS addon</a
    ></li
  ><li
  ><a href="primitives.html"
    >Primitives addon</a
    ></li
  ></ul
><!-- keep blank line for correct HTML -->
</div>

<div class="searchbox">
<script type="text/javascript">
function onSubmit(form) {
    for (i = 0; i < search_index.length; i++) {
        if (search_index[i] == form.q.value) {
            form.action = search_urls[i];
            form.method = "POST";
            return true;
        }
    }
    // Search-term is not in the index.
    // We could add an URL here which does a fulltext search - for
    // now we simply do nothing by return false to the form.
    return false;
}
</script>
<form id="search" action="search.py" onSubmit="return onSubmit(this);"><input type="text" name="q" id="q" autocomplete="off" /><br /> <input type="submit" value="Search" /><script>actb = new actb("q", search_index);</script>
</form>
</div>


</td>
<td class="content">


<div id="toc"
    ><ul
      ><li
	><a href="#threads" id="TOC-threads"
	  >Threads</a
	  ><ul
	  ><li
	    ><a href="#allegro_thread" id="TOC-allegro_thread"
	      >ALLEGRO_THREAD</a
	      ></li
	    ><li
	    ><a href="#allegro_mutex" id="TOC-allegro_mutex"
	      >ALLEGRO_MUTEX</a
	      ></li
	    ><li
	    ><a href="#allegro_cond" id="TOC-allegro_cond"
	      >ALLEGRO_COND</a
	      ></li
	    ><li
	    ><a href="#al_create_thread" id="TOC-al_create_thread"
	      >al_create_thread</a
	      ></li
	    ><li
	    ><a href="#al_start_thread" id="TOC-al_start_thread"
	      >al_start_thread</a
	      ></li
	    ><li
	    ><a href="#al_join_thread" id="TOC-al_join_thread"
	      >al_join_thread</a
	      ></li
	    ><li
	    ><a href="#al_set_thread_should_stop" id="TOC-al_set_thread_should_stop"
	      >al_set_thread_should_stop</a
	      ></li
	    ><li
	    ><a href="#al_get_thread_should_stop" id="TOC-al_get_thread_should_stop"
	      >al_get_thread_should_stop</a
	      ></li
	    ><li
	    ><a href="#al_destroy_thread" id="TOC-al_destroy_thread"
	      >al_destroy_thread</a
	      ></li
	    ><li
	    ><a href="#al_create_mutex" id="TOC-al_create_mutex"
	      >al_create_mutex</a
	      ></li
	    ><li
	    ><a href="#al_create_mutex_recursive" id="TOC-al_create_mutex_recursive"
	      >al_create_mutex_recursive</a
	      ></li
	    ><li
	    ><a href="#al_lock_mutex" id="TOC-al_lock_mutex"
	      >al_lock_mutex</a
	      ></li
	    ><li
	    ><a href="#al_unlock_mutex" id="TOC-al_unlock_mutex"
	      >al_unlock_mutex</a
	      ></li
	    ><li
	    ><a href="#al_destroy_mutex" id="TOC-al_destroy_mutex"
	      >al_destroy_mutex</a
	      ></li
	    ><li
	    ><a href="#al_create_cond" id="TOC-al_create_cond"
	      >al_create_cond</a
	      ></li
	    ><li
	    ><a href="#al_destroy_cond" id="TOC-al_destroy_cond"
	      >al_destroy_cond</a
	      ></li
	    ><li
	    ><a href="#al_wait_cond" id="TOC-al_wait_cond"
	      >al_wait_cond</a
	      ></li
	    ><li
	    ><a href="#al_wait_cond_timed" id="TOC-al_wait_cond_timed"
	      >al_wait_cond_timed</a
	      ></li
	    ><li
	    ><a href="#al_broadcast_cond" id="TOC-al_broadcast_cond"
	      >al_broadcast_cond</a
	      ></li
	    ><li
	    ><a href="#al_signal_cond" id="TOC-al_signal_cond"
	      >al_signal_cond</a
	      ></li
	    ></ul
	  ></li
	></ul
      ></div
    ><h1 id="threads"
    ><a href="#TOC-threads"
      >Threads</a
      ></h1
    ><p
    >Allegro 4.9 includes a simple cross-platform threading interface. It is a thin layer on top of two threading APIs: Windows threads and POSIX Threads (pthreads). Enforcing a consistent semantics on all platforms would be difficult at best, hence the behaviour of the following functions will differ subtly on different platforms (more so than usual). Your best bet is to be aware of this and code to the intersection of the semantics and avoid edge cases.</p
    ><h2 id="allegro_thread"
    ><a href="#TOC-allegro_thread"
      >ALLEGRO_THREAD</a
      ></h2
    ><pre
    ><code
      >typedef struct ALLEGRO_THREAD ALLEGRO_THREAD;
</code
      ></pre
    ><p
    >An opaque structure representing a thread.</p
    ><h2 id="allegro_mutex"
    ><a href="#TOC-allegro_mutex"
      >ALLEGRO_MUTEX</a
      ></h2
    ><pre
    ><code
      >typedef struct ALLEGRO_MUTEX ALLEGRO_MUTEX;
</code
      ></pre
    ><p
    >An opaque structure representing a mutex.</p
    ><h2 id="allegro_cond"
    ><a href="#TOC-allegro_cond"
      >ALLEGRO_COND</a
      ></h2
    ><pre
    ><code
      >typedef struct ALLEGRO_COND ALLEGRO_COND;
</code
      ></pre
    ><p
    >An opaque structure representing a condition variable.</p
    ><h2 id="al_create_thread"
    ><a href="#TOC-al_create_thread"
      >al_create_thread</a
      ></h2
    ><pre
    ><code
      >ALLEGRO_THREAD *al_create_thread(
   void *(*proc)(ALLEGRO_THREAD *thread, void *arg),
   void *arg)
</code
      ></pre
    ><p
    >Spawn a new thread which begins executing <code
      >proc</code
      >. The new thread is passed its own thread handle and the value <code
      >arg</code
      >.</p
    ><p
    ><em
      >Return value:</em
      ></p
    ><p
    >Returns true if the thread was created, false if there was an error.</p
    ><p
    ><em
      >See also:</em
      > <a href="threads.html#al_start_thread"
      >al_start_thread</a
      >, <a href="threads.html#al_join_thread"
      >al_join_thread</a
      >.</p
    ><h2 id="al_start_thread"
    ><a href="#TOC-al_start_thread"
      >al_start_thread</a
      ></h2
    ><pre
    ><code
      >void al_start_thread(ALLEGRO_THREAD *outer)
</code
      ></pre
    ><p
    >When a thread is created, it is initially in a suspended state. Calling <code
      >al_start_thread</code
      > will start its actual execution.</p
    ><p
    >Starting a thread which has already been started does nothing.</p
    ><p
    ><em
      >See also:</em
      > <a href="threads.html#al_create_thread"
      >al_create_thread</a
      >.</p
    ><h2 id="al_join_thread"
    ><a href="#TOC-al_join_thread"
      >al_join_thread</a
      ></h2
    ><pre
    ><code
      >void al_join_thread(ALLEGRO_THREAD *outer, void **ret_value)
</code
      ></pre
    ><p
    >Wait for the thread to finish executing. This implicitly calls <code
      >al_set_thread_should_stop</code
      > first.</p
    ><p
    >If <code
      >ret_value</code
      > is non-<code
      >NULL</code
      >, the value returned by the thread function will be stored at the location pointed to by <code
      >ret_value</code
      >.</p
    ><p
    ><em
      >See also:</em
      > <a href="threads.html#al_set_thread_should_stop"
      >al_set_thread_should_stop</a
      >, <a href="threads.html#al_get_thread_should_stop"
      >al_get_thread_should_stop</a
      >, <a href="threads.html#al_destroy_thread"
      >al_destroy_thread</a
      >.</p
    ><h2 id="al_set_thread_should_stop"
    ><a href="#TOC-al_set_thread_should_stop"
      >al_set_thread_should_stop</a
      ></h2
    ><pre
    ><code
      >void al_set_thread_should_stop(ALLEGRO_THREAD *outer)
</code
      ></pre
    ><p
    >Set the flag to indicate <code
      >thread</code
      > should stop. Returns immediately.</p
    ><p
    ><em
      >See also:</em
      > <a href="threads.html#al_join_thread"
      >al_join_thread</a
      >, <a href="threads.html#al_get_thread_should_stop"
      >al_get_thread_should_stop</a
      >.</p
    ><h2 id="al_get_thread_should_stop"
    ><a href="#TOC-al_get_thread_should_stop"
      >al_get_thread_should_stop</a
      ></h2
    ><pre
    ><code
      >bool al_get_thread_should_stop(ALLEGRO_THREAD *outer)
</code
      ></pre
    ><p
    >Check if another thread is waiting for <code
      >thread</code
      > to stop. Threads which run in a loop should check this periodically and act on it when convenient.</p
    ><p
    ><em
      >Return value:</em
      ></p
    ><p
    >Return true if another thread has called <code
      >al_join_thread</code
      > or <code
      >al_set_thread_should_stop</code
      > on this thread.</p
    ><p
    ><em
      >See also:</em
      > <a href="threads.html#al_join_thread"
      >al_join_thread</a
      >, <a href="threads.html#al_set_thread_should_stop"
      >al_set_thread_should_stop</a
      >.</p
    ><p
    ><em
      >Note:</em
      > We don't support forceful killing of threads.</p
    ><h2 id="al_destroy_thread"
    ><a href="#TOC-al_destroy_thread"
      >al_destroy_thread</a
      ></h2
    ><pre
    ><code
      >void al_destroy_thread(ALLEGRO_THREAD *outer)
</code
      ></pre
    ><p
    >Free the resources used by a thread. Implicitly performs <code
      >al_join_thread</code
      > on the thread if it hasn't been done already.</p
    ><p
    >Does nothing if <code
      >thread</code
      > is NULL.</p
    ><p
    ><em
      >See also:</em
      > <a href="threads.html#al_join_thread"
      >al_join_thread</a
      >.</p
    ><h2 id="al_create_mutex"
    ><a href="#TOC-al_create_mutex"
      >al_create_mutex</a
      ></h2
    ><pre
    ><code
      >ALLEGRO_MUTEX *al_create_mutex(void)
</code
      ></pre
    ><p
    >Create the mutex object (a mutual exclusion device). The mutex may or may not support &quot;recursive&quot; locking.</p
    ><p
    ><em
      >Return value:</em
      ></p
    ><p
    >Returns the mutex on success or <code
      >NULL</code
      > on error.</p
    ><p
    ><em
      >See also:</em
      > <a href="threads.html#al_create_mutex_recursive"
      >al_create_mutex_recursive</a
      >.</p
    ><h2 id="al_create_mutex_recursive"
    ><a href="#TOC-al_create_mutex_recursive"
      >al_create_mutex_recursive</a
      ></h2
    ><pre
    ><code
      >ALLEGRO_MUTEX *al_create_mutex_recursive(void)
</code
      ></pre
    ><p
    >Create the mutex object (a mutual exclusion device), with support for &quot;recursive&quot; locking. That is, the mutex will count the number of times it has been locked by the same thread. If the caller tries to acquire a lock on the mutex when it already holds the lock then the count is incremented. The mutex is only unlocked when the thread releases the lock on the mutex an equal number of times, i.e. the count drops down to zero.</p
    ><p
    ><em
      >See also:</em
      > <a href="threads.html#al_create_mutex"
      >al_create_mutex</a
      >.</p
    ><h2 id="al_lock_mutex"
    ><a href="#TOC-al_lock_mutex"
      >al_lock_mutex</a
      ></h2
    ><pre
    ><code
      >void al_lock_mutex(ALLEGRO_MUTEX *mutex)
</code
      ></pre
    ><p
    >Acquire the lock on <code
      >mutex</code
      >. If the mutex is already locked by another thread, the call will block until the mutex becomes available and locked.</p
    ><p
    >If the mutex is already locked by the calling thread, then the behaviour depends on whether the mutex was created with <code
      >al_create_mutex</code
      > or <code
      >al_create_mutex_recursive</code
      >. In the former case, the behaviour is undefined; the most likely behaviour is deadlock. In the latter case, the count in the mutex will be incremented and the call will return immediately.</p
    ><p
    ><em
      >See also:</em
      > <a href="threads.html#al_unlock_mutex"
      >al_unlock_mutex</a
      >.</p
    ><p
    ><strong
      >We don't yet have al_mutex_trylock.</strong
      ></p
    ><h2 id="al_unlock_mutex"
    ><a href="#TOC-al_unlock_mutex"
      >al_unlock_mutex</a
      ></h2
    ><pre
    ><code
      >void al_unlock_mutex(ALLEGRO_MUTEX *mutex)
</code
      ></pre
    ><p
    >Release the lock on <code
      >mutex</code
      > if the calling thread holds the lock on it.</p
    ><p
    >If the calling thread doesn't hold the lock, or if the mutex is not locked, undefined behaviour results.</p
    ><p
    ><em
      >See also:</em
      > <a href="threads.html#al_lock_mutex"
      >al_lock_mutex</a
      >.</p
    ><h2 id="al_destroy_mutex"
    ><a href="#TOC-al_destroy_mutex"
      >al_destroy_mutex</a
      ></h2
    ><pre
    ><code
      >void al_destroy_mutex(ALLEGRO_MUTEX *mutex)
</code
      ></pre
    ><p
    >Free the resources used by the mutex. The mutex should be unlocked. Destroying a locked mutex results in undefined behaviour.</p
    ><p
    >Does nothing if <code
      >mutex</code
      > is <code
      >NULL</code
      >.</p
    ><h2 id="al_create_cond"
    ><a href="#TOC-al_create_cond"
      >al_create_cond</a
      ></h2
    ><pre
    ><code
      >ALLEGRO_COND *al_create_cond(void)
</code
      ></pre
    ><p
    >Create a condition variable.</p
    ><p
    ><em
      >Return value:</em
      ></p
    ><p
    >Returns the condition value on success or <code
      >NULL</code
      > on error.</p
    ><h2 id="al_destroy_cond"
    ><a href="#TOC-al_destroy_cond"
      >al_destroy_cond</a
      ></h2
    ><pre
    ><code
      >void al_destroy_cond(ALLEGRO_COND *cond)
</code
      ></pre
    ><p
    >Destroy a condition variable.</p
    ><p
    >Destroying a condition variable which has threads block on it results in undefined behaviour.</p
    ><p
    >Does nothing if <code
      >cond</code
      > is <code
      >NULL</code
      >.</p
    ><h2 id="al_wait_cond"
    ><a href="#TOC-al_wait_cond"
      >al_wait_cond</a
      ></h2
    ><pre
    ><code
      >void al_wait_cond(ALLEGRO_COND *cond, ALLEGRO_MUTEX *mutex)
</code
      ></pre
    ><p
    >On entering this function, <code
      >mutex</code
      > must be locked by the calling thread. The function will atomically release <code
      >mutex</code
      > and block on <code
      >cond</code
      >. The function will return when <code
      >cond</code
      > is &quot;signalled&quot;, acquiring the lock on the mutex in the process.</p
    ><p
    >Example of proper use:</p
    ><pre
    ><code
      >al_lock_mutex(mutex);
while (something_not_true) {
    al_wait_cond(cond, mutex);
}
do_something();
al_unlock_mutex(mutex);
</code
      ></pre
    ><p
    >The mutex should be locked before checking the condition, and should be rechecked <code
      >al_wait_cond</code
      > returns. <code
      >al_wait_cond</code
      > can return for other reasons than the condition becoming true (e.g. the process was signalled). If multiple threads are blocked on the condition variable, the condition may no longer be true by the time the second and later threads are unblocked. Remember not to unlock the mutex prematurely.</p
    ><p
    ><em
      >See also:</em
      > <a href="threads.html#al_wait_cond_timed"
      >al_wait_cond_timed</a
      >, <a href="threads.html#al_broadcast_cond"
      >al_broadcast_cond</a
      >, <a href="threads.html#al_signal_cond"
      >al_signal_cond</a
      >.</p
    ><h2 id="al_wait_cond_timed"
    ><a href="#TOC-al_wait_cond_timed"
      >al_wait_cond_timed</a
      ></h2
    ><pre
    ><code
      >int al_wait_cond_timed(ALLEGRO_COND *cond, ALLEGRO_MUTEX *mutex,
   const ALLEGRO_TIMEOUT *timeout)
</code
      ></pre
    ><p
    >Like <code
      >al_wait_cond</code
      > but the call can return if the absolute time passes <code
      >timeout</code
      > before the condition is signalled.</p
    ><p
    ><em
      >Return value:</em
      ></p
    ><p
    >Returns zero on success, non-zero if the call timed out.</p
    ><p
    ><strong
      >Fix up the return value. pthread_cond_timedwait returns ETIMEDOUT but can return other errors. Do we need to return other errors?</strong
      ></p
    ><h2 id="al_broadcast_cond"
    ><a href="#TOC-al_broadcast_cond"
      >al_broadcast_cond</a
      ></h2
    ><pre
    ><code
      >void al_broadcast_cond(ALLEGRO_COND *cond)
</code
      ></pre
    ><p
    >Unblock all threads currently waiting on a condition variable. That is, broadcast that some condition which those threads were waiting for has become true.</p
    ><p
    ><em
      >See also:</em
      > <a href="threads.html#al_signal_cond"
      >al_signal_cond</a
      >.</p
    ><p
    ><em
      >Note:</em
      > The pthreads spec says to lock the mutex associated with <code
      >cond</code
      > before signalling for predictable scheduling behaviour.</p
    ><h2 id="al_signal_cond"
    ><a href="#TOC-al_signal_cond"
      >al_signal_cond</a
      ></h2
    ><pre
    ><code
      >void al_signal_cond(ALLEGRO_COND *cond)
</code
      ></pre
    ><p
    >Unblock at least one thread waiting on a condition variable.</p
    ><p
    >Generally you should use <code
      >al_broadcast_cond</code
      > but <code
      >al_signal_cond</code
      > may be more efficient when it's applicable.</p
    ><p
    ><em
      >See also:</em
      > <a href="threads.html#al_broadcast_cond"
      >al_broadcast_cond</a
      >.</p
    ></td>
</tr>
</table>


<p>
Last updated: 2009-06-07 09:43:08 UTC
</p>
</body
  ></html
>

