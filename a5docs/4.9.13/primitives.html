<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"
><head
  ><title
    >Primitives Addon</title
    ><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"
     /><meta name="generator" content="pandoc"
     /><script type="text/javascript" src="autosuggest.js"></script>
<script type="text/javascript" src="search_index.js"></script>
<link rel="stylesheet" href="pandoc.css" type="text/css" media="all" />
</head
  ><body
  ><table class="white">
<tr>
<td valign="top" class="sidebar">

<div class="sidebar">
<ul
><li
  ><strong
    ><a href="index.html"
      >Contents</a
      ></strong
    ></li
  ><li
  ><a href="config.html"
    >Configuration files</a
    ></li
  ><li
  ><a href="display.html"
    >Display</a
    ></li
  ><li
  ><a href="events.html"
    >Events</a
    ></li
  ><li
  ><a href="file.html"
    >File I/O</a
    ></li
  ><li
  ><a href="fshook.html"
    >Filesystem hooks</a
    ></li
  ><li
  ><a href="graphics.html"
    >Graphics</a
    ></li
  ><li
  ><a href="joystick.html"
    >Joystick</a
    ></li
  ><li
  ><a href="keyboard.html"
    >Keyboard</a
    ></li
  ><li
  ><a href="memory.html"
    >Memory</a
    ></li
  ><li
  ><a href="misc.html"
    >Miscellaneous</a
    ></li
  ><li
  ><a href="mouse.html"
    >Mouse</a
    ></li
  ><li
  ><a href="opengl.html"
    >OpenGL</a
    ></li
  ><li
  ><a href="path.html"
    >Path</a
    ></li
  ><li
  ><a href="platform.html"
    >Platform-specific</a
    ></li
  ><li
  ><a href="state.html"
    >State</a
    ></li
  ><li
  ><a href="system.html"
    >System</a
    ></li
  ><li
  ><a href="threads.html"
    >Threads</a
    ></li
  ><li
  ><a href="time.html"
    >Time</a
    ></li
  ><li
  ><a href="timer.html"
    >Timer</a
    ></li
  ><li
  ><a href="utf8.html"
    >UTF-8</a
    ></li
  ><li
  ><strong
    ><a href="index.html#addons"
      >Addons</a
      ></strong
    ></li
  ><li
  ><a href="kcm_audio.html"
    >Audio addon</a
    ></li
  ><li
  ><a href="acodec.html"
    >Audio codecs</a
    ></li
  ><li
  ><a href="color.html"
    >Color addon</a
    ></li
  ><li
  ><a href="font.html"
    >Font addons</a
    ></li
  ><li
  ><a href="iio.html"
    >Image I/O addon</a
    ></li
  ><li
  ><a href="native_dialog.html"
    >Native dialogs addon</a
    ></li
  ><li
  ><a href="physfs.html"
    >PhysicsFS addon</a
    ></li
  ><li
  ><a href="primitives.html"
    >Primitives addon</a
    ></li
  ></ul
><!-- keep blank line for correct HTML -->
</div>

<div class="searchbox">
<script type="text/javascript">
function onSubmit(form) {
    for (i = 0; i < search_index.length; i++) {
        if (search_index[i] == form.q.value) {
            form.action = search_urls[i];
            form.method = "POST";
            return true;
        }
    }
    // Search-term is not in the index.
    // We could add an URL here which does a fulltext search - for
    // now we simply do nothing by return false to the form.
    return false;
}
</script>
<form id="search" action="search.py" onsubmit="return onSubmit(this);"><input type="text" name="q" id="q" size="15" autocomplete="off" /><br /> <input type="submit" value="Search" /><script type="text/javascript">actb = new actb("q", search_index);</script>
</form>
</div>


</td>
<td class="content">


<h1 class="title"
    >Primitives Addon</h1
    ><div id="toc"
    ><ul
      ><li
	><a href="#high-level-drawing-routines" id="TOC-high-level-drawing-routines"
	  >High Level Drawing Routines</a
	  ><ul
	  ><li
	    ><a href="#al_draw_line" id="TOC-al_draw_line"
	      >al_draw_line</a
	      ></li
	    ><li
	    ><a href="#al_draw_triangle" id="TOC-al_draw_triangle"
	      >al_draw_triangle</a
	      ></li
	    ><li
	    ><a href="#al_draw_filled_triangle" id="TOC-al_draw_filled_triangle"
	      >al_draw_filled_triangle</a
	      ></li
	    ><li
	    ><a href="#al_draw_rectangle" id="TOC-al_draw_rectangle"
	      >al_draw_rectangle</a
	      ></li
	    ><li
	    ><a href="#al_draw_filled_rectangle" id="TOC-al_draw_filled_rectangle"
	      >al_draw_filled_rectangle</a
	      ></li
	    ><li
	    ><a href="#al_draw_rounded_rectangle" id="TOC-al_draw_rounded_rectangle"
	      >al_draw_rounded_rectangle</a
	      ></li
	    ><li
	    ><a href="#al_draw_filled_rounded_rectangle" id="TOC-al_draw_filled_rounded_rectangle"
	      >al_draw_filled_rounded_rectangle</a
	      ></li
	    ><li
	    ><a href="#al_calculate_arc" id="TOC-al_calculate_arc"
	      >al_calculate_arc</a
	      ></li
	    ><li
	    ><a href="#al_draw_ellipse" id="TOC-al_draw_ellipse"
	      >al_draw_ellipse</a
	      ></li
	    ><li
	    ><a href="#al_draw_filled_ellipse" id="TOC-al_draw_filled_ellipse"
	      >al_draw_filled_ellipse</a
	      ></li
	    ><li
	    ><a href="#al_draw_circle" id="TOC-al_draw_circle"
	      >al_draw_circle</a
	      ></li
	    ><li
	    ><a href="#al_draw_filled_circle" id="TOC-al_draw_filled_circle"
	      >al_draw_filled_circle</a
	      ></li
	    ><li
	    ><a href="#al_draw_arc" id="TOC-al_draw_arc"
	      >al_draw_arc</a
	      ></li
	    ><li
	    ><a href="#al_calculate_spline" id="TOC-al_calculate_spline"
	      >al_calculate_spline</a
	      ></li
	    ><li
	    ><a href="#al_draw_spline" id="TOC-al_draw_spline"
	      >al_draw_spline</a
	      ></li
	    ><li
	    ><a href="#al_calculate_ribbon" id="TOC-al_calculate_ribbon"
	      >al_calculate_ribbon</a
	      ></li
	    ><li
	    ><a href="#al_draw_ribbon" id="TOC-al_draw_ribbon"
	      >al_draw_ribbon</a
	      ></li
	    ></ul
	  ></li
	><li
	><a href="#low-level-drawing-routines" id="TOC-low-level-drawing-routines"
	  >Low Level Drawing Routines</a
	  ><ul
	  ><li
	    ><a href="#al_draw_prim" id="TOC-al_draw_prim"
	      >al_draw_prim</a
	      ></li
	    ><li
	    ><a href="#al_draw_indexed_prim" id="TOC-al_draw_indexed_prim"
	      >al_draw_indexed_prim</a
	      ></li
	    ><li
	    ><a href="#al_get_allegro_color" id="TOC-al_get_allegro_color"
	      >al_get_allegro_color</a
	      ></li
	    ><li
	    ><a href="#al_get_prim_color" id="TOC-al_get_prim_color"
	      >al_get_prim_color</a
	      ></li
	    ><li
	    ><a href="#al_draw_soft_triangle" id="TOC-al_draw_soft_triangle"
	      >al_draw_soft_triangle</a
	      ></li
	    ><li
	    ><a href="#al_draw_soft_line" id="TOC-al_draw_soft_line"
	      >al_draw_soft_line</a
	      ></li
	    ></ul
	  ></li
	><li
	><a href="#transformations" id="TOC-transformations"
	  >Transformations</a
	  ><ul
	  ><li
	    ><a href="#al_copy_transform" id="TOC-al_copy_transform"
	      >al_copy_transform</a
	      ></li
	    ><li
	    ><a href="#al_use_transform" id="TOC-al_use_transform"
	      >al_use_transform</a
	      ></li
	    ><li
	    ><a href="#al_identity_transform" id="TOC-al_identity_transform"
	      >al_identity_transform</a
	      ></li
	    ><li
	    ><a href="#al_build_transform" id="TOC-al_build_transform"
	      >al_build_transform</a
	      ></li
	    ><li
	    ><a href="#al_translate_transform" id="TOC-al_translate_transform"
	      >al_translate_transform</a
	      ></li
	    ><li
	    ><a href="#al_rotate_transform" id="TOC-al_rotate_transform"
	      >al_rotate_transform</a
	      ></li
	    ><li
	    ><a href="#al_scale_transform" id="TOC-al_scale_transform"
	      >al_scale_transform</a
	      ></li
	    ><li
	    ><a href="#al_transform_vertex" id="TOC-al_transform_vertex"
	      >al_transform_vertex</a
	      ></li
	    ><li
	    ><a href="#al_transform_transform" id="TOC-al_transform_transform"
	      >al_transform_transform</a
	      ></li
	    ></ul
	  ></li
	><li
	><a href="#structures-and-types" id="TOC-structures-and-types"
	  >Structures and Types</a
	  ><ul
	  ><li
	    ><a href="#allegro_prim_color" id="TOC-allegro_prim_color"
	      >ALLEGRO_PRIM_COLOR</a
	      ></li
	    ><li
	    ><a href="#allegro_vertex" id="TOC-allegro_vertex"
	      >ALLEGRO_VERTEX</a
	      ></li
	    ><li
	    ><a href="#allegro_transform" id="TOC-allegro_transform"
	      >ALLEGRO_TRANSFORM</a
	      ></li
	    ></ul
	  ></li
	><li
	><a href="#constants" id="TOC-constants"
	  >Constants</a
	  ><ul
	  ><li
	    ><a href="#allegro_prim_type" id="TOC-allegro_prim_type"
	      >ALLEGRO_PRIM_TYPE</a
	      ></li
	    ><li
	    ><a href="#allegro_vertex_cache_size" id="TOC-allegro_vertex_cache_size"
	      >ALLEGRO_VERTEX_CACHE_SIZE</a
	      ></li
	    ><li
	    ><a href="#allegro_prim_quality" id="TOC-allegro_prim_quality"
	      >ALLEGRO_PRIM_QUALITY</a
	      ></li
	    ></ul
	  ></li
	></ul
      ></div
    ><h1 id="high-level-drawing-routines"
    ><a href="#TOC-high-level-drawing-routines"
      >High Level Drawing Routines</a
      ></h1
    ><h2 id="al_draw_line"
    ><a href="#TOC-al_draw_line"
      >al_draw_line</a
      ></h2
    ><pre
    ><code
      >void al_draw_line(float x1, float y1, float x2, float y2,
   ALLEGRO_COLOR color, float thickness)
</code
      ></pre
    ><p
    >Draws a line segment between two points.</p
    ><p
    ><em
      >Parameters:</em
      ></p
    ><ul
    ><li
      >x1, y1, x2, y2 - Start and end points of the line</li
      ><li
      >color - Color of the line</li
      ><li
      >thickness - Thickness of the line, pass <code
	>&lt;= 0</code
	> to draw hairline lines</li
      ></ul
    ><h2 id="al_draw_triangle"
    ><a href="#TOC-al_draw_triangle"
      >al_draw_triangle</a
      ></h2
    ><pre
    ><code
      >void al_draw_triangle(float x1, float y1, float x2, float y2,
   float x3, float y3, ALLEGRO_COLOR color, float thickness)
</code
      ></pre
    ><p
    >Draws an outlined triangle.</p
    ><p
    ><em
      >Parameters:</em
      ></p
    ><ul
    ><li
      >x1, y1, x2, y2, x3, y3 - Three points of the triangle</li
      ><li
      >color - Color of the triangle</li
      ><li
      >thickness - Thickness of the lines, pass <code
	>&lt;= 0</code
	> to draw hairline lines</li
      ></ul
    ><h2 id="al_draw_filled_triangle"
    ><a href="#TOC-al_draw_filled_triangle"
      >al_draw_filled_triangle</a
      ></h2
    ><pre
    ><code
      >void al_draw_filled_triangle(float x1, float y1, float x2, float y2,
   float x3, float y3, ALLEGRO_COLOR color)
</code
      ></pre
    ><p
    >Draws a filled triangle.</p
    ><p
    ><em
      >Parameters:</em
      ></p
    ><ul
    ><li
      >x1, y1, x2, y2, x3, y3 - Three points of the triangle</li
      ><li
      >color - Color of the triangle</li
      ></ul
    ><h2 id="al_draw_rectangle"
    ><a href="#TOC-al_draw_rectangle"
      >al_draw_rectangle</a
      ></h2
    ><pre
    ><code
      >void al_draw_rectangle(float x1, float y1, float x2, float y2,
   ALLEGRO_COLOR color, float thickness)
</code
      ></pre
    ><p
    >Draws an outlined rectangle.</p
    ><p
    ><em
      >Parameters:</em
      ></p
    ><ul
    ><li
      >x1, y1, x2, y2 - Upper left and lower right points of a rectangle</li
      ><li
      >color - Color of the rectangle</li
      ><li
      >thickness - Thickness of the lines, pass <code
	>&lt;= 0</code
	> to draw hairline lines</li
      ></ul
    ><h2 id="al_draw_filled_rectangle"
    ><a href="#TOC-al_draw_filled_rectangle"
      >al_draw_filled_rectangle</a
      ></h2
    ><pre
    ><code
      >void al_draw_filled_rectangle(float x1, float y1, float x2, float y2,
   ALLEGRO_COLOR color)
</code
      ></pre
    ><p
    >Draws a filled rectangle.</p
    ><p
    ><em
      >Parameters:</em
      ></p
    ><ul
    ><li
      >x1, y1, x2, y2 - Upper left and lower right points of a rectangle</li
      ><li
      >color - Color of the rectangle</li
      ></ul
    ><h2 id="al_draw_rounded_rectangle"
    ><a href="#TOC-al_draw_rounded_rectangle"
      >al_draw_rounded_rectangle</a
      ></h2
    ><pre
    ><code
      >void al_draw_rounded_rectangle(float x1, float y1, float x2, float y2,
   float rx, float ry, ALLEGRO_COLOR color, float thickness)
</code
      ></pre
    ><p
    >Draws an outlined rounded rectangle.</p
    ><p
    ><em
      >Parameters:</em
      ></p
    ><ul
    ><li
      >x1, y1, x2, y2 - Upper left and lower right points of a rectangle</li
      ><li
      >color - Color of the rectangle</li
      ><li
      >rx, ry - The radii of the round</li
      ><li
      >thickness - Thickness of the lines, pass <code
	>&lt;= 0</code
	> to draw hairline lines</li
      ></ul
    ><h2 id="al_draw_filled_rounded_rectangle"
    ><a href="#TOC-al_draw_filled_rounded_rectangle"
      >al_draw_filled_rounded_rectangle</a
      ></h2
    ><pre
    ><code
      >void al_draw_filled_rounded_rectangle(float x1, float y1, float x2, float y2,
   float rx, float ry, ALLEGRO_COLOR color)
</code
      ></pre
    ><p
    >Draws an filled rounded rectangle.</p
    ><p
    ><em
      >Parameters:</em
      ></p
    ><ul
    ><li
      >x1, y1, x2, y2 - Upper left and lower right points of a rectangle</li
      ><li
      >color - Color of the rectangle</li
      ><li
      >rx, ry - The radii of the round</li
      ></ul
    ><h2 id="al_calculate_arc"
    ><a href="#TOC-al_calculate_arc"
      >al_calculate_arc</a
      ></h2
    ><pre
    ><code
      >void al_calculate_arc(float* dest, int stride, float cx, float cy,
   float rx, float ry, float start_theta, float delta_theta, float thickness,
   int num_segments)
</code
      ></pre
    ><p
    >Calculates an elliptical arc, and sets the vertices in the destination to the calculated positions. If <code
      >thickness &lt;= 0</code
      >, then <code
      >num_points</code
      > of points are required in the destination, otherwise twice as many are needed. The destination buffer should consist of regularly spaced (by distance of stride bytes) doublets of floats, corresponding to x and y coordinates of the vertices.</p
    ><p
    ><em
      >Parameters:</em
      ></p
    ><ul
    ><li
      >dest - Pointer to the destination buffer</li
      ><li
      >stride - Distance (in bytes) between successive pairs of coordinates</li
      ><li
      >cx, cy - Center of the arc</li
      ><li
      >rx, ry - Radii of the arc</li
      ><li
      >start_theta - The initial angle from which the arc is calculated</li
      ><li
      >delta_theta - Angular span of the arc (pass a negative number to switch direction)</li
      ><li
      >thickness - Thickness of the arc</li
      ><li
      >num_points - The number of points to calculate</li
      ></ul
    ><h2 id="al_draw_ellipse"
    ><a href="#TOC-al_draw_ellipse"
      >al_draw_ellipse</a
      ></h2
    ><pre
    ><code
      >void al_draw_ellipse(float cx, float cy, float rx, float ry,
   ALLEGRO_COLOR color, float thickness)
</code
      ></pre
    ><p
    >Draws an outlined ellipse.</p
    ><p
    ><em
      >Parameters:</em
      ></p
    ><ul
    ><li
      >cx, cy - Center of the ellipse</li
      ><li
      >rx, ry - Radii of the ellipse</li
      ><li
      >color - Color of the ellipse</li
      ><li
      >thickness - Thickness of the ellipse, pass <code
	>&lt;= 0</code
	> to draw hairline ellipse</li
      ></ul
    ><h2 id="al_draw_filled_ellipse"
    ><a href="#TOC-al_draw_filled_ellipse"
      >al_draw_filled_ellipse</a
      ></h2
    ><pre
    ><code
      >void al_draw_filled_ellipse(float cx, float cy, float rx, float ry,
   ALLEGRO_COLOR color)
</code
      ></pre
    ><p
    >Draws a filled ellipse.</p
    ><p
    ><em
      >Parameters:</em
      ></p
    ><ul
    ><li
      >cx, cy - Center of the ellipse</li
      ><li
      >rx, ry - Radii of the ellipse</li
      ><li
      >color - Color of the ellipse</li
      ></ul
    ><h2 id="al_draw_circle"
    ><a href="#TOC-al_draw_circle"
      >al_draw_circle</a
      ></h2
    ><pre
    ><code
      >void al_draw_circle(float cx, float cy, float r, ALLEGRO_COLOR color,
   float thickness)
</code
      ></pre
    ><p
    >Draws an outlined circle.</p
    ><p
    ><em
      >Parameters:</em
      ></p
    ><ul
    ><li
      >cx, cy - Center of the circle</li
      ><li
      >r - Radius of the circle</li
      ><li
      >color - Color of the circle</li
      ><li
      >thickness - Thickness of the circle, pass <code
	>&lt;= 0</code
	> to draw hairline circle</li
      ></ul
    ><h2 id="al_draw_filled_circle"
    ><a href="#TOC-al_draw_filled_circle"
      >al_draw_filled_circle</a
      ></h2
    ><pre
    ><code
      >void al_draw_filled_circle(float cx, float cy, float r, ALLEGRO_COLOR color)
</code
      ></pre
    ><p
    >Draws a filled circle.</p
    ><p
    ><em
      >Parameters:</em
      ></p
    ><ul
    ><li
      >cx, cy - Center of the circle</li
      ><li
      >r - Radius of the circle</li
      ><li
      >color - Color of the circle</li
      ></ul
    ><h2 id="al_draw_arc"
    ><a href="#TOC-al_draw_arc"
      >al_draw_arc</a
      ></h2
    ><pre
    ><code
      >void al_draw_arc(float cx, float cy, float r, float start_theta,
   float delta_theta, ALLEGRO_COLOR color, float thickness)
</code
      ></pre
    ><p
    >Draws an arc.</p
    ><p
    ><em
      >Parameters:</em
      ></p
    ><ul
    ><li
      >cx, cy - Center of the arc</li
      ><li
      >r - Radius of the arc</li
      ><li
      >color - Color of the arc</li
      ><li
      >start_theta - The initial angle from which the arc is calculated</li
      ><li
      >delta_theta - Angular span of the arc (pass a negative number to switch direction)</li
      ><li
      >thickness - Thickness of the circle, pass <code
	>&lt;= 0</code
	> to draw hairline circle</li
      ></ul
    ><h2 id="al_calculate_spline"
    ><a href="#TOC-al_calculate_spline"
      >al_calculate_spline</a
      ></h2
    ><pre
    ><code
      >void al_calculate_spline(float* dest, int stride, float points[8],
   float thickness, int num_segments)
</code
      ></pre
    ><p
    >Calculates a spline given 4 control points. If <code
      >thickness &lt;= 0</code
      >, then <code
      >num_segments</code
      > of points are required in the destination, otherwise twice as many are needed. The destination buffer should consist of regularly spaced (by distance of stride bytes) doublets of floats, corresponding to x and y coordinates of the vertices.</p
    ><p
    ><em
      >Parameters:</em
      ></p
    ><ul
    ><li
      >dest - Pointer to the destination buffer</li
      ><li
      >stride - Distance (in bytes) between successive pairs of coordinates</li
      ><li
      >points - An array of 4 pairs of coordinates of the 4 control points</li
      ><li
      >thickness - Thickness of the spline ribbon</li
      ><li
      >num_segments - The number of points to calculate</li
      ></ul
    ><h2 id="al_draw_spline"
    ><a href="#TOC-al_draw_spline"
      >al_draw_spline</a
      ></h2
    ><pre
    ><code
      >void al_draw_spline(float points[8], ALLEGRO_COLOR color, float thickness)
</code
      ></pre
    ><p
    >Draws a spline given 4 control points.</p
    ><p
    ><em
      >Parameters:</em
      ></p
    ><ul
    ><li
      >points - An array of 4 pairs of coordinates of the 4 control points</li
      ><li
      >color - Color of the spline</li
      ><li
      >thickness - Thickness of the spline, pass <code
	>&lt;= 0</code
	> to draw hairline spline</li
      ></ul
    ><h2 id="al_calculate_ribbon"
    ><a href="#TOC-al_calculate_ribbon"
      >al_calculate_ribbon</a
      ></h2
    ><pre
    ><code
      >void al_calculate_ribbon(float* dest, int dest_stride, const float *points,
   int points_stride, float thickness, int num_segments)
</code
      ></pre
    ><p
    >Calculates a ribbon given an array of points. The ribbon will go through all of the passed points. If <code
      >thickness &lt;= 0</code
      >, then <code
      >num_segments</code
      > of points are required in the destination buffer, otherwise twice as many are needed. The destination and the points buffer should consist of regularly spaced doublets of floats, corresponding to x and y coordinates of the vertices.</p
    ><p
    ><em
      >Parameters:</em
      ></p
    ><ul
    ><li
      >dest - Pointer to the destination buffer</li
      ><li
      >dest_stride - Distance (in bytes) between successive pairs of coordinates in the destination buffer</li
      ><li
      >points - An array of pairs of coordinates for each point</li
      ><li
      >points_stride - Distance (in bytes) between successive pairs of coordinates in the points buffer</li
      ><li
      >thickness - Thickness of the spline ribbon</li
      ><li
      >num_segments - The number of points to calculate</li
      ></ul
    ><h2 id="al_draw_ribbon"
    ><a href="#TOC-al_draw_ribbon"
      >al_draw_ribbon</a
      ></h2
    ><pre
    ><code
      >void al_draw_ribbon(const float *points, int points_stride, ALLEGRO_COLOR color,
   float thickness, int num_segments)
</code
      ></pre
    ><p
    >Draws a ribbon given given an array of points. The ribbon will go through all of the passed points.</p
    ><p
    ><em
      >Parameters:</em
      ></p
    ><ul
    ><li
      >points - An array of pairs of coordinates for each point</li
      ><li
      >color - Color of the spline</li
      ><li
      >thickness - Thickness of the spline, pass <code
	>&lt;= 0</code
	> to draw hairline spline</li
      ></ul
    ><h1 id="low-level-drawing-routines"
    ><a href="#TOC-low-level-drawing-routines"
      >Low Level Drawing Routines</a
      ></h1
    ><h2 id="al_draw_prim"
    ><a href="#TOC-al_draw_prim"
      >al_draw_prim</a
      ></h2
    ><pre
    ><code
      >int al_draw_prim(ALLEGRO_VERTEX* vtxs, ALLEGRO_BITMAP* texture,
   int start, int end, int type)
</code
      ></pre
    ><p
    >Draws a subset of the passed vertex buffer. It is recommended for the texture to have its dimensions be a power of 2 for maximum portability with older video cards.</p
    ><p
    ><em
      >Parameters:</em
      ></p
    ><ul
    ><li
      >texture - Texture to use, pass 0 to use only shaded primitves</li
      ><li
      >vtxs - Pointer to an array of vertices</li
      ><li
      >start, end - Start and end of the subset of the vertex buffer to draw</li
      ><li
      >type - Primitive type to draw</li
      ></ul
    ><p
    ><em
      >Returns:</em
      > Number of primitives drawn</p
    ><p
    ><em
      >See Also:</em
      > <a href="primitives.html#allegro_vertex"
      >ALLEGRO_VERTEX</a
      >, <a href="primitives.html#allegro_prim_type"
      >ALLEGRO_PRIM_TYPE</a
      >, <a href="primitives.html#al_draw_indexed_prim"
      >al_draw_indexed_prim</a
      ></p
    ><h2 id="al_draw_indexed_prim"
    ><a href="#TOC-al_draw_indexed_prim"
      >al_draw_indexed_prim</a
      ></h2
    ><pre
    ><code
      >int al_draw_indexed_prim(ALLEGRO_VERTEX* vtxs, ALLEGRO_BITMAP* texture,
   const int* indices, int num_vtx, int type)
</code
      ></pre
    ><p
    >Draws a subset of the passed vertex buffer. This function uses an index array to specify which vertices to use. It is recommended for the texture to have its dimensions be a power of 2 for maximum portability with older video cards.</p
    ><p
    ><em
      >Parameters:</em
      ></p
    ><ul
    ><li
      >texture - Texture to use, pass 0 to use only shaded primitves</li
      ><li
      >vtxs - Pointer to an array of vertices</li
      ><li
      >indices - An array of indices into the vertex buffer</li
      ><li
      >num_vtx - Number of indices from the indices array you want to draw</li
      ><li
      >type - Primitive type to draw</li
      ></ul
    ><p
    ><em
      >Returns:</em
      > Number of primitives drawn</p
    ><p
    ><em
      >See Also:</em
      > <a href="primitives.html#allegro_vertex"
      >ALLEGRO_VERTEX</a
      >, <a href="primitives.html#allegro_prim_type"
      >ALLEGRO_PRIM_TYPE</a
      >, <a href="primitives.html#al_draw_prim"
      >al_draw_prim</a
      ></p
    ><h2 id="al_get_allegro_color"
    ><a href="#TOC-al_get_allegro_color"
      >al_get_allegro_color</a
      ></h2
    ><pre
    ><code
      >ALLEGRO_COLOR al_get_allegro_color(ALLEGRO_PRIM_COLOR col)
</code
      ></pre
    ><p
    >Converts an <code
      >ALLEGRO_PRIM_COLOR</code
      > into a <code
      >ALLEGRO_COLOR</code
      >.</p
    ><p
    ><em
      >Parameters:</em
      ></p
    ><ul
    ><li
      >col - ALLEGRO_PRIM_COLOR to convert</li
      ></ul
    ><p
    ><em
      >Returns:</em
      > Converted ALLEGRO_COLOR</p
    ><p
    ><em
      >See Also:</em
      > <a href="primitives.html#allegro_prim_color"
      >ALLEGRO_PRIM_COLOR</a
      >, <a href="primitives.html#al_get_prim_color"
      >al_get_prim_color</a
      ></p
    ><h2 id="al_get_prim_color"
    ><a href="#TOC-al_get_prim_color"
      >al_get_prim_color</a
      ></h2
    ><pre
    ><code
      >ALLEGRO_PRIM_COLOR al_get_prim_color(ALLEGRO_COLOR col)
</code
      ></pre
    ><p
    >Converts an <code
      >ALLEGRO_COLOR</code
      > into a <code
      >ALLEGRO_PRIM_COLOR</code
      >.</p
    ><p
    ><em
      >Parameters:</em
      ></p
    ><ul
    ><li
      >col - ALLEGRO_COLOR to convert</li
      ></ul
    ><p
    ><em
      >Returns:</em
      > Converted ALLEGRO_PRIM_COLOR</p
    ><p
    ><em
      >See Also:</em
      > <a href="primitives.html#allegro_prim_color"
      >ALLEGRO_PRIM_COLOR</a
      >, <a href="primitives.html#al_get_allegro_color"
      >al_get_allegro_color</a
      ></p
    ><h2 id="al_draw_soft_triangle"
    ><a href="#TOC-al_draw_soft_triangle"
      >al_draw_soft_triangle</a
      ></h2
    ><pre
    ><code
      >void al_draw_soft_triangle(
   ALLEGRO_VERTEX* v1, ALLEGRO_VERTEX* v2, ALLEGRO_VERTEX* v3, uintptr_t state,
   void (*init)(uintptr_t, ALLEGRO_VERTEX*, ALLEGRO_VERTEX*, ALLEGRO_VERTEX*),
   void (*first)(uintptr_t, int, int, int, int),
   void (*step)(uintptr_t, int), 
   void (*draw)(uintptr_t, int, int, int))
</code
      ></pre
    ><p
    >Draws a triangle using the software rasterizer and user supplied pixel functions. For help in understanding what these functions do, see the implementation of the various shading routines in addons/primitives/tri_soft.c. The triangle is drawn in two segments, from top to bottom. The segments are deliniated by the vertically middle vertex of the triangle. One of each segment may be absent if two vertices are horizontally collinear.</p
    ><p
    ><em
      >Parameters:</em
      ></p
    ><ul
    ><li
      >v1, v2, v3 - The three vertices of the triangle</li
      ><li
      >state - A pointer to a user supplied struct, this struct will be passed to all the pixel functions</li
      ><li
      >init - This function is called once, before any drawing is done. The three points passed to it may be altered by clipping.</li
      ><li
      >first - The function is called twice, once per triangle segment. It is passed 4 parameters, the first two are the coordinates of the initial pixel drawn in the segment. The second two are the left minor and the left major steps, respectively. They represent the sizes of two steps taken by the rasterizer as it walks on the left side of the triangle. From then on, the each step will either be classified as a minor or a major step, corresponding to the above values.</li
      ><li
      >step - Called once per scanline. The last parameter is set to 1 if the step is a minor step, and 0 if it is a major step.</li
      ><li
      >draw - Called once per scanline. The function is expected to draw the scanline starting with a point specified by the first two parameters (corresponding to x and y values) going to the right until it reaches the value of the third parameter (the x value of the end point). All coordinates are inclusive.</li
      ></ul
    ><h2 id="al_draw_soft_line"
    ><a href="#TOC-al_draw_soft_line"
      >al_draw_soft_line</a
      ></h2
    ><pre
    ><code
      >void al_draw_soft_line(ALLEGRO_VERTEX* v1, ALLEGRO_VERTEX* v2, uintptr_t state,
   void (*first)(uintptr_t, int, int, ALLEGRO_VERTEX*, ALLEGRO_VERTEX*),
   void (*step)(uintptr_t, int),
   void (*draw)(uintptr_t, int, int))
</code
      ></pre
    ><p
    >Draws a line using the software rasterizer and user supplied pixel functions. For help in understanding what these functions do, see the implementation of the various shading routines in addons/primitives/line_soft.c. The line is drawn top to bottom.</p
    ><p
    ><em
      >Parameters:</em
      ></p
    ><ul
    ><li
      >v1, v2 - The two vertices of the line</li
      ><li
      >state - A pointer to a user supplied struct, this struct will be passed to all the pixel functions</li
      ><li
      >first - The function is called before drawing the first pixel of the line. It is passed the coordinates of this pixel, as well as the two vertices above. The passed vertices may have been altered by clipping.</li
      ><li
      >step - Called once per pixel. The second parameter is set to 1 if the step is a minor step, and 0 if this step is a major step. Minor steps are taken only either in x or y directions. Major steps are taken in both directions diagonally. In all cases, the the absolute value of the change in coordinate is at most 1 in either direction.</li
      ><li
      >draw - Called once per pixel. The function is expected to draw the pixel at the two coordinates passed to it.</li
      ></ul
    ><h1 id="transformations"
    ><a href="#TOC-transformations"
      >Transformations</a
      ></h1
    ><h2 id="al_copy_transform"
    ><a href="#TOC-al_copy_transform"
      >al_copy_transform</a
      ></h2
    ><pre
    ><code
      >void al_copy_transform(ALLEGRO_TRANSFORM* src, ALLEGRO_TRANSFORM* dest)
</code
      ></pre
    ><p
    >Makes a copy of a transformation.</p
    ><p
    ><em
      >Parameters:</em
      ></p
    ><ul
    ><li
      >src - Source transformation</li
      ><li
      >dest - Destination transformation</li
      ></ul
    ><h2 id="al_use_transform"
    ><a href="#TOC-al_use_transform"
      >al_use_transform</a
      ></h2
    ><pre
    ><code
      >void al_use_transform(ALLEGRO_TRANSFORM* trans)
</code
      ></pre
    ><p
    >Sets the transformation to be used for the primitive drawing operations. Every drawing operation after this call will be transformed using this transformation. Call this function with the identity before using non-primitive drawing functions (e.g. drawing bitmaps), otherwise the behaviour of those functions will not be defined.</p
    ><p
    ><em
      >Parameters:</em
      ></p
    ><ul
    ><li
      >trans - Transformation to use</li
      ></ul
    ><h2 id="al_identity_transform"
    ><a href="#TOC-al_identity_transform"
      >al_identity_transform</a
      ></h2
    ><pre
    ><code
      >void al_identity_transform(ALLEGRO_TRANSFORM* trans)
</code
      ></pre
    ><p
    >Sets the transformation to be the identity transformation.</p
    ><p
    ><em
      >Parameters:</em
      ></p
    ><ul
    ><li
      >trans - Transformation to alter</li
      ></ul
    ><h2 id="al_build_transform"
    ><a href="#TOC-al_build_transform"
      >al_build_transform</a
      ></h2
    ><pre
    ><code
      >void al_build_transform(ALLEGRO_TRANSFORM* trans, float x, float y,
   float sx, float sy, float theta)
</code
      ></pre
    ><p
    >Builds a transformation given some parameters. This call is equivalent to calling the transformations in this order: make identity, scale, rotate, translate. This method is faster, however.</p
    ><p
    ><em
      >Parameters:</em
      ></p
    ><ul
    ><li
      >trans - Transformation to alter</li
      ><li
      >x, y - Translation</li
      ><li
      >sx, sy - Scale</li
      ><li
      >theta - Rotation angle</li
      ></ul
    ><h2 id="al_translate_transform"
    ><a href="#TOC-al_translate_transform"
      >al_translate_transform</a
      ></h2
    ><pre
    ><code
      >void al_translate_transform(ALLEGRO_TRANSFORM* trans, float x, float y)
</code
      ></pre
    ><p
    >Apply a translation to a transformation.</p
    ><p
    ><em
      >Parameters:</em
      ></p
    ><ul
    ><li
      >trans - Transformation to alter</li
      ><li
      >x, y - Translation</li
      ></ul
    ><h2 id="al_rotate_transform"
    ><a href="#TOC-al_rotate_transform"
      >al_rotate_transform</a
      ></h2
    ><pre
    ><code
      >void al_rotate_transform(ALLEGRO_TRANSFORM* trans, float theta)
</code
      ></pre
    ><p
    >Apply a rotation to a transformation.</p
    ><p
    ><em
      >Parameters:</em
      ></p
    ><ul
    ><li
      >trans - Transformation to alter</li
      ><li
      >theta - Rotation angle</li
      ></ul
    ><h2 id="al_scale_transform"
    ><a href="#TOC-al_scale_transform"
      >al_scale_transform</a
      ></h2
    ><pre
    ><code
      >void al_scale_transform(ALLEGRO_TRANSFORM* trans, float sx, float sy)
</code
      ></pre
    ><p
    >Apply a scale to a transformation.</p
    ><p
    ><em
      >Parameters:</em
      ></p
    ><ul
    ><li
      >trans - Transformation to alter</li
      ><li
      >sx, sy - Scale</li
      ></ul
    ><h2 id="al_transform_vertex"
    ><a href="#TOC-al_transform_vertex"
      >al_transform_vertex</a
      ></h2
    ><pre
    ><code
      >void al_transform_vertex(ALLEGRO_TRANSFORM* trans, ALLEGRO_VERTEX* vtx)
</code
      ></pre
    ><p
    >Transform a vertex.</p
    ><p
    ><em
      >Parameters:</em
      ></p
    ><ul
    ><li
      >trans - Transformation to use</li
      ><li
      >vtx - Vertex to transform</li
      ></ul
    ><h2 id="al_transform_transform"
    ><a href="#TOC-al_transform_transform"
      >al_transform_transform</a
      ></h2
    ><pre
    ><code
      >void al_transform_transform(ALLEGRO_TRANSFORM* trans, ALLEGRO_TRANSFORM* trans2)
</code
      ></pre
    ><p
    >Transform a transformation.</p
    ><p
    ><em
      >Parameters:</em
      ></p
    ><ul
    ><li
      >trans - Transformation to use</li
      ><li
      >trans2 - Transformation to transform</li
      ></ul
    ><h1 id="structures-and-types"
    ><a href="#TOC-structures-and-types"
      >Structures and Types</a
      ></h1
    ><h2 id="allegro_prim_color"
    ><a href="#TOC-allegro_prim_color"
      >ALLEGRO_PRIM_COLOR</a
      ></h2
    ><pre
    ><code
      >typedef struct ALLEGRO_PRIM_COLOR ALLEGRO_PRIM_COLOR;
</code
      ></pre
    ><p
    >A special structure that defines a color in a way that understandable to both OpenGL and Direct3D backends. You should never access internal fields, instead using the two conversion functions to convert between it and <a href="graphics.html#allegro_color"
      >ALLEGRO_COLOR</a
      > structure.</p
    ><p
    ><em
      >See Also:</em
      > <a href="primitives.html#al_get_allegro_color"
      >al_get_allegro_color</a
      >, <a href="primitives.html#al_get_prim_color"
      >al_get_prim_color</a
      ></p
    ><h2 id="allegro_vertex"
    ><a href="#TOC-allegro_vertex"
      >ALLEGRO_VERTEX</a
      ></h2
    ><pre
    ><code
      >typedef struct ALLEGRO_VERTEX ALLEGRO_VERTEX;
</code
      ></pre
    ><p
    >Defines the generic vertex type, with a 2D position, color and texture coordinates for a single texture.</p
    ><ul
    ><li
      >x, y - Position of the vertex.</li
      ><li
      >color - <code
	>ALLEGRO_PRIM_COLOR</code
	> structure</li
      ><li
      >u, v - Texture coordinates</li
      ></ul
    ><p
    ><em
      >See Also:</em
      > <a href="primitives.html#allegro_prim_color"
      >ALLEGRO_PRIM_COLOR</a
      ></p
    ><h2 id="allegro_transform"
    ><a href="#TOC-allegro_transform"
      >ALLEGRO_TRANSFORM</a
      ></h2
    ><pre
    ><code
      >typedef float ALLEGRO_TRANSFORM[4][4];
</code
      ></pre
    ><p
    >Defines the generic transformation type, a 4x4 matrix. 2D transforms use only a small subsection of this matrix, namely the top left 2x2 matrix, and the right most 2x1 matrix, for a total of 6 values.</p
    ><h1 id="constants"
    ><a href="#TOC-constants"
      >Constants</a
      ></h1
    ><h2 id="allegro_prim_type"
    ><a href="#TOC-allegro_prim_type"
      >ALLEGRO_PRIM_TYPE</a
      ></h2
    ><pre
    ><code
      >enum ALLEGRO_PRIM_TYPE {
</code
      ></pre
    ><p
    >Enumerates the types of primitives this addon can draw.</p
    ><ul
    ><li
      ><p
	>ALLEGRO_PRIM_LINE_LIST - A list of lines, sequential pairs of vertices define disjointed lines</p
	></li
      ><li
      ><p
	>ALLEGRO_PRIM_LINE_STRIP - A strip of lines, sequential vertices define a strip of lines</p
	></li
      ><li
      ><p
	>ALLEGRO_PRIM_LINE_LOOP - Like a line strip, except at the end the first and the last vertices are also connected by a line</p
	></li
      ><li
      ><p
	>ALLEGRO_PRIM_TRIANGLE_LIST - A list of triangles, sequential triplets of vertices define disjointed triangles</p
	></li
      ><li
      ><p
	>ALLEGRO_PRIM_TRIANGLE_STRIP - A strip of triangles, sequential vertices define a strip of triangles</p
	></li
      ><li
      ><p
	>ALLEGRO_PRIM_TRIANGLE_FAN - A fan of triangles, all triangles share the first vertex</p
	></li
      ></ul
    ><h2 id="allegro_vertex_cache_size"
    ><a href="#TOC-allegro_vertex_cache_size"
      >ALLEGRO_VERTEX_CACHE_SIZE</a
      ></h2
    ><pre
    ><code
      >#define ALLEGRO_VERTEX_CACHE_SIZE 256
</code
      ></pre
    ><p
    >Defines the size of the transformation vertex cache for the software renderer. If you pass less than this many vertices to the primitive rendering functions you will get a speed boost. This also defines the size of the cache vertex buffer, used for the high-level primitives. This corresponds to the maximum number of line segments that will be used to form them.</p
    ><h2 id="allegro_prim_quality"
    ><a href="#TOC-allegro_prim_quality"
      >ALLEGRO_PRIM_QUALITY</a
      ></h2
    ><pre
    ><code
      >#define ALLEGRO_PRIM_QUALITY 10
</code
      ></pre
    ><p
    >Defines the quality of the quadratic primitives. At 10, this roughly corresponds to error &lt; 0.5 pixel.</p
    ></td>
</tr>
</table>


<p>
Last updated: 2009-08-09 08:22:44 UTC
</p>
</body
  ></html
>

