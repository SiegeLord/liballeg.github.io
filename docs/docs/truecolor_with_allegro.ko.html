<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
   <head>
      <title>Pot of gold...</title>
      <meta http-equiv="Content-Type" content="text/html; charset=euc-kr">
      <meta name="author" content="Shawn Hargreaves">
      <meta name="translator" content="Seunghwan Ji">
   </head>
   <body text="#000000" bgcolor="#FFFFFF" link="#0000EF" vlink="#51188E" alink="#FF0000">
   
<center><h1><b>
...<font color="#FF0000">무</font><font color="#FF4000"></font><font color="#FF8000"></font><font color="#FFC000">지</font><font color="#FFFF00"></font><font color="#A0FF00"></font><font color="#60FF00">개</font><font color="#00FF00"></font><font color="#00FF60"></font><font color="#00FFA0">의</font> <font color="#00FFFF"></font><font color="#00A0FF"></font><font color="#0060FF">끝</font><font color="#0000FF"></font><font color="#6000FF"></font><font color="#A000FF">에</font><font color="#FF00FF"></font><font color="#FF00A0"></font><font color="#FF0060">서</font><font color="#FF0000"></font>
</b></h1><p><h3><i>
<font color="#3366FF">Allegro 트루컬러 시작하기</font>
</i></h3></center>
<p>
<hr>
<p>
<i>
1998에 한마디: Allegro 3.0의 베타 버전이 막 시작되었을 때, 익숙한 256 컬러
함수와 새로운 트루컬러 모드에 대한 차이를 알고 싶어하는 사람들을 위해,
이 글을 작성하였습니다. 용어가 좀 이상하다면 이것은 다음의 이유에서입니다:
이 글은 초보자를 위한 튜토리얼이 아니라 경험있는 사용자에게 몇가지 새로운
특성를 설명하기 위해 작성되었습니다. 하지만 아마도 두 가지 목적에 모두
부합할 수 있을 것이며, 이것이 제가 이 글을 여기에 남겨둔 이유입니다.
</i><p><br>
자, 시작합니다. 수 많은 새로운 그래픽 코드, 수백만개의 추가 색상, 그리고
귀찮은 8비트 팔레트 이미지를 사용하지 않는 것. 하지만 실제로 새로운 함수가
매우 많은 것은 아닙니다: 기존 루틴이 조금 다른 방식으로 동작하는 경우가
더 많습니다. 물론 메인 라이브러리 문서에서 자세한 설명을 찾을 수 있지만,
이 문서가 이미 256 색상 API에 익숙하며, 단지 트루컬러 모드의 차이점을
알고 싶은 사람들에게 바로 시작할 수 있는 유용한 가이드가 될 수 있으리라
생각합니다. 그러면, 어떻게 트루컬러 해상도를 사용하는 것일까요?
<p>
<hr>
<p>
<b>짧은 답변:</b>
<p>
set_gfx_mode()의 앞에서 set_color_depth()를 호출하십시오.
<p>
<hr>
<p>
<b>중간 답변:</b>
<p>
set_color_depth()를 프로그램의 시작 부분에서 호출합니다 
(set_gfx_mode()를 호출하기 전에, 그리고 비트맵 데이터를 디스크에서
읽기 전에).
<p>
makecol() 함수를 사용하여 (또는 사용할 색상 비트수를 확실히 알고 있는
경우에는 makecol15(), makecol16() 등을 사용하여) Red, Green, Blue의
값을 비디오 하드웨어에서 사용되는 형식으로 변환하고, 그 결과인 정수
색상값을 그리기 함수에서 사용합니다.
<p>
마스크 픽셀에 대응하는 0(zero) 대신에 마젠타 (Red와 Blue 값은 최대이며,
Green은 0인 색상)를 사용하십시오.
<p>
<hr>
<p>
<b>긴 답변:</b>
<p>
표준 8비트 팔레트 모드뿐만 아니라, Allegro는 이제 15, 16비트 하이컬러
모드와 24, 32비트 트루컬러 모드도 지원합니다. 15비트 모드에서는
Red, Green, Blue 각각 5비트씩 할당되며, 사용되지 않는 1비트가 추가되어
하나의 픽셀을 구성합니다. 16비트 모드에서는 Red와 Blue 5비트씩과
Green 6비트로 구성됩니다. 24비트 모드에서는 각 픽셀이 Red, Green, Blue의
3개의 바이트로 구성되며 (이러한 구성은 데이터 정렬상 좋지 않기 때문에
처리 속도를 느리게 하는 경향이 있습니다), 32비트 모드에서는 24비트
모드에서와 마찬가지의 구성에 추가로 하나의 예비 바이트가 추가되어
데이터 정렬상 유리한 형태로 유지됩니다.
<p>
어떤 모드를 사용할 것인가는 그래픽 카드와 VESA 드라이버에 따라 결정됩니다.
대부분의 그래픽 카드는 15비트와 16비트 모드 모두를 지원하지만, 둘 중의
하나를 사용할 수 없는 경우를 대비하여 가능한한 두가지 모두를 지원하도록
충고하고 싶습니다 (이것은 그리 어려운 일은 아닙니다..). 어떤 그래픽 
카드는 24비트와 32비트 트루컬러 모드를 지원하며, 이 경우에는 24비트를
사용하여 메모리를 절약하거나 32비트를 사용하여 속도를 높이는 두가지 중의
하나를 선택할 수 있지만, 오래된 그래픽 카드 중의 상당수는 32비트 모드를
가지고 있지 않으며, 신형 그래픽 카드 중의 많은 것들이 24비트 모드를 
지원하지 않습니다. 대부분의 그래픽 카드는 표준 SVGA 해상도를 지원하며,
UniVBE를 사용하면 320x200, 320x240 등의 저해상도 트루컬러 모드를
지원할 수도 있습니다. 1M의 비디오 RAM이 장착되어 있는 그래픽 카드는
640x480 하이컬로 모드를 지원하며, 선형 프레임버퍼를 가지고 있다면
800x600 모드도 지원합니다. 2M 비디오 RAM이 있는 경우에는 2 페이지의 
640x480 하이컬러 모드, 800x600 하이컬러 모드 (선형 프레임버퍼를 가지고
있는 경우에는 2 페이지), 1024x768 하이컬러 모드, 640x480 트루컬러
모드를 사용할 수 있습니다 (선형 프레임버퍼를 가지고 있는 경우 800x600
트루컬러 모드도 가능). 4M 비디오 RAM이 있다면 거의 무엇이든 가능합니다
:-)
<p>
Allegro는 전역 색상 비트수 설정을 사용하며, set_color_depth(newdepth)를
호출하여 변경될 수 있습니다. 이것은 그 자체로는 아무 일도 하지 않지만,
설정 값은 이후의 set_gfx_mode(), create_bitmap(), 그리고 모든 비트맵이나
데이터파일 읽기 명령 등에 영향을 주게 되므로, 보통은 사용하고자 하는
색상 비트수를 지정하기 위해 프로그램의 시작부에 한번만 이것을 사용합니다.
<p>
모든 트루컬러 픽셀 값은 8비트 모드와 똑같이 정수 값으로 그리기 함수에 
전달됩니다. 각 색상 비트들이 어떻게 사용되는가는 사용하는 모드에 따라
달라질 수 있으므로, 프로그램에서 비트 패턴을 하드코딩하는 것은 피해야
합니다 (0을 검은색으로, 모두 1인 경우를 흰색으로 하는 것을 제외하고).
대신 makecol() 함수를 사용하여 Red, Green, Blue 값 (0~255의 범위)을
현재 색상 비트두에 맞는 형식으로 변환하거나, 사용할 색상 비트수를 확실히
알고 있는 경우에는 더 빠른 버전인 makecol15(), makecol16() 등의 함수로
변환하여 사용하십시오. getr(), getg(), getb() 함수나 고속의 getr15(),
getr16() 등의 함수를 사용하여 픽셀 값에서 개별적인 색상을 추출할 수 
있습니다. 이들 함수는 set_gfx_mode()를 호출하기 전까지는 알 수 없는
색상 비트의 형식 (RGB 또는 BGR 형식)을 알아야 동작할 수 있으므로, 
이들 루틴을 사용하기 전에 항상 비디오 모드를 선택하여야 합니다.
<p>
비트맵 오브젝트는 데이터파일 (어떤 색상 비트수도 가능), .PCX 파일
(8, 24비트 색상), .BMP 파일 (8, 24비트 색상), .LBM 파일
(8비트 색상), .TGA 파일 (8, 15, 24비트 색상)에서 읽혀질 수 있습니다.
기본은 데이터가 현재의 색상 비트수 형식으로 자동 변환 되어 읽져지는
것이지만, set_color_conversion() 함수를 호출하여 원래의 형식을
유지하도록 요구할 수 있습니다. 이미지 읽기 루틴은 디스플레이 하드웨어에서
사용하는 픽셀 형식을 알아야 하므로, 이미지를 읽기 전에 비디오 모드를
설정해 주어야 합니다 (텍스트 모드에서 이미지를 읽는다면 어떤 그래픽
카드에서는 색이 정확하게 표시되지 않으며 불분명한 버그를 유발할 수
있습니다). 트루컬러 이미지를 포함하는 컴파일된 데이터파일을 사용한다면,
스크린 모드를 설정한 후에 fixup_datafile()을 호출하여 데이터가
올바른 형식이 되도록 하여야 합니다.
<p>
트루컬러 모드에서는 256색 모드에서와는 달리 0을 검은색을 저장하는데 
사용하므로, 스프라이트에서 투명한 픽셀을 마킹하기 위해 0을 사용하지
않습니다. 대신에 Allegro는 밝은 핑크 (Red와 Blue는 최대이고 Green은
0인 색상)를 사용합니다. 이 값은 makecol(0xFF, 0, 0xFF)를 호출하여
구하고나, 각 색상 비트수에 따라 정의되는 상수인 MASK_COLOR_8, 
MASK_COLOR_15, MASK_COLOR_16 등이 될 수 있으며, 특정 비트맵의 투명 색상을
알고 싶은 경우에는 bitmap_mask_color(bmp)를 사용하면 됩니다.
<p>
일반적으로, Allegro는 한번에 하나의 색상 비트수만을 사용하도록 
설계되었으므로, set_color_depth()를 한번 호출하고서 모든 비트맵을
같은 형식으로 저장혀 사용하게 될 것입니다. 여러 가지 픽셀 형식을
혼용하여야 하는 경우에는, create_bitmap() 대신 create_bitmap_ex()를
사용할 수 있으며, bitmap_color_depth()를 호출하여 특정 이미지의
픽셀 형식을 구할 수 있습니다. 대부분의 그래픽 루틴은 모든 입력
파라미터가 동일한 형식일 것을 요구합니다 (예: 15비트 비트맵을
24비트 비트맵에 확장하여 그릴 수 없습니다). 하지만 세가지 예외가
있습니다: blit()는 다른 비트맵 형식 사이에서 사용될 경우 데이터 형식을
자동으로 변환하며, draw_sprite()는 256색 이미지를 어떠한 형식의
비트맵 안에라도 그릴 수 있습니다. 그리고 draw_character()는 어떤
형식의 비트맵 안에 그리는 경우라도 _항상_ 256색 비트맵을 대상으로
사용합니다. 256색 비트맵을 트루컬러 비트맵 안에 그리도록 하는 것은
매우 빠르게 동작합니다 (이러한 변환 작업 전에 올바른 팔레트를 확실히
설정해 두어야 합니다!). 다른 트루컬러 형식 사이의 변환은 조금 
느리며, 트루컬러 이미지를 256색으로 변환하는 것은 매우 느립니다
(변환하기 전에 전역 rgb_map 테이블을 설정하면 속도가 상당히 빨라질
수 있습니다).
<p>
트루컬러 모드에서는 하드웨어 팔레트가 없습니다. 그러므로 팔레트 페이딩
함수는 동작하지 않습니다. 256색과 트루컬러 형식의 변환을 위해 사용될
팔레트를 지정하기 위해 set_palette()를 호출할 수는 있습니다.
전역 배열인 palette_color[]는 현재 비디오 모드에 맞는 형식으로 모든
팔레트의 색상 값이 저장됩니다. 그러므로 트루컬러 모드에서 
현재 팔레트의 3번 색상으로 한 라인을 그리려면 palette_color[3]을
line() 함수에 색상 값으로 넣어주십시오.
<p>
반투명 관련 작업은 트루컬러 모드에서는 완전히 다르게 동작합니다:
color_map 테이들은 사용되지 않습니다. 대신에 set_blender_mode()나
set_trans_blender()를 빛나거나 반투명인 오브젝트를 그리기 전에
호출하여야 합니다.
<p>
트루컬러 비트맵의 내용을 직접 억세스하고 싶은 경우, 256색 모드에서
하였던 것과 마찬가지로 bmp-&gt;line[] 테이블이나 bmp_write_line() 함수를 
사용할 수 있습니다. 15나 16비트 모드에서는 line 포인터를 (unsigned short*)로
캐스팅하여 사용하거나 _farpokew() 함수를 사용할 수 있으며, 32비트 모드에서는
(unsigned long*)으로 캐스팅하거나 _farpokel()을 사용할 수 있습니다.
24비트 모드에서는 하나의 픽셀이 3개의 바이트로 표시되므로 억세스하기가
조금 더 힘듭니다: 연속되는 3개의 바이트를 8비트 line 데이터에 쓰도록 하거나,
하나의 short와 하나의 추가바이트로 캐스트하여 사용할 수도 있습니다.
<p>
_putpixel()과 _getpixel() 인라인 함수는 256색 모드에서만 동작하며, 
3D 다각형 그리기 함수도 트루컬러 모드를 지원하지 않습니다.
다른 모든 그래픽 함수는 어떠한 모드에서도 동작할 것입니다.
<p>
트루컬러 모드에서 GUI 루틴을 사용하고 싶은 경우에는, 전역 변수인 gui_fg_color,
gui_mg_color, gui_bg_color를 적당한 값으로 설정해 주어야 합니다 
(makecol() 함수의 리턴 값으로, 보통 검음색, 회색, 흰색을 사용합니다).
<p>
누군가는 이 문서가 유용하다고 생각하게 되기를 바랍니다 (그렇지 않으면
제가 아침 내내 한 작업이 쓸모 없는 것이 되기 때문입니다 :-) 하고 싶은
말이나 질문, 문제점 등은 
<a href="mailto:shawn@talula.demon.co.uk">shawn@talula.demon.co.uk</a>로
보내 주십시오.


</body>
</html>
